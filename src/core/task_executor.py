import asyncio
import time
from typing import List, Optional, Dict, Any
import logging
from ..llm.command_processor import Task
from ..integrations.home_assistant import HomeAssistantClient

logger = logging.getLogger(__name__)

class TaskExecutor:
    """Executes tasks generated by the command processor"""
    
    def __init__(self, home_assistant: Optional[HomeAssistantClient] = None, 
                 spotify_client: Optional[Any] = None):
        self.home_assistant = home_assistant
        self.spotify_client = spotify_client
        self.presence_detector = None
        self.tts = None
        self.execution_history = []
        
        logger.info("Task executor initialized")
    
    def set_integrations(self, home_assistant=None, spotify=None, presence_detector=None, tts=None):
        """Set or update integrations"""
        if home_assistant is not None:
            self.home_assistant = home_assistant
        if spotify is not None:
            self.spotify_client = spotify
        if presence_detector is not None:
            self.presence_detector = presence_detector
        if tts is not None:
            self.tts = tts
        
        logger.info("Task executor integrations updated")
    
    async def execute_tasks(self, tasks: List[Task]) -> Dict[str, Any]:
        """Execute a list of tasks in priority order"""
        if not tasks:
            return {"success": True, "executed": 0, "errors": []}
        
        # Sort tasks by priority (1 = highest priority)
        sorted_tasks = sorted(tasks, key=lambda t: t.priority)
        
        results = {
            "success": True,
            "executed": 0,
            "errors": [],
            "task_results": []
        }
        
        for task in sorted_tasks:
            try:
                logger.info(f"Executing task: {task.action} on {task.target}")
                task_result = await self._execute_single_task(task)
                
                results["task_results"].append({
                    "task": task,
                    "success": task_result["success"],
                    "message": task_result.get("message", "")
                })
                
                if task_result["success"]:
                    results["executed"] += 1
                else:
                    results["errors"].append(f"{task.action}: {task_result.get('error', 'Unknown error')}")
                    results["success"] = False
                
                # Add small delay between tasks
                await asyncio.sleep(0.5)
                
            except Exception as e:
                error_msg = f"Error executing {task.action}: {str(e)}"
                logger.error(error_msg)
                results["errors"].append(error_msg)
                results["success"] = False
        
        # Store execution history
        self.execution_history.append({
            "timestamp": time.time(),
            "tasks": tasks,
            "results": results
        })
        
        return results
    
    async def _execute_single_task(self, task: Task) -> Dict[str, Any]:
        """Execute a single task"""
        try:
            if task.action == "turn_on_lights":
                return await self._turn_on_lights(task)
            elif task.action == "turn_off_lights":
                return await self._turn_off_lights(task)
            elif task.action == "play_music":
                return await self._play_music(task)
            elif task.action == "pause_music":
                return await self._pause_music(task)
            elif task.action == "resume_music":
                return await self._resume_music(task)
            elif task.action == "set_volume":
                return await self._set_volume(task)
            else:
                return {
                    "success": False,
                    "error": f"Unknown action: {task.action}"
                }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _turn_on_lights(self, task: Task) -> Dict[str, Any]:
        """Turn on lights"""
        if not self.home_assistant:
            return {"success": False, "error": "Home Assistant not configured"}
        
        room = task.parameters.get("room", task.target)
        brightness = task.parameters.get("brightness")
        color = task.parameters.get("color")
        
        try:
            if room:
                success = self.home_assistant.turn_on_room_lights(room, brightness)
            else:
                # Turn on specific light
                success = self.home_assistant.turn_on_light(task.target, brightness, color)
            
            if success:
                return {
                    "success": True,
                    "message": f"Turned on lights in {room or task.target}"
                }
            else:
                return {
                    "success": False,
                    "error": f"Failed to turn on lights in {room or task.target}"
                }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _turn_off_lights(self, task: Task) -> Dict[str, Any]:
        """Turn off lights"""
        if not self.home_assistant:
            return {"success": False, "error": "Home Assistant not configured"}
        
        room = task.parameters.get("room", task.target)
        
        try:
            if room:
                success = self.home_assistant.turn_off_room_lights(room)
            else:
                success = self.home_assistant.turn_off_light(task.target)
            
            if success:
                return {
                    "success": True,
                    "message": f"Turned off lights in {room or task.target}"
                }
            else:
                return {
                    "success": False,
                    "error": f"Failed to turn off lights in {room or task.target}"
                }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _play_music(self, task: Task) -> Dict[str, Any]:
        """Play music on Spotify"""
        if not self.spotify_client:
            return {"success": False, "error": "Spotify not configured"}
        
        query = task.parameters.get("query", "")
        device = task.parameters.get("device", "")
        music_type = task.parameters.get("type", "track")
        
        try:
            # This is a simplified implementation
            # In practice, you'd search for the content and play it
            if device:
                device_obj = self.spotify_client.find_device_by_name(device)
                if device_obj:
                    device_id = device_obj['id']
                else:
                    return {"success": False, "error": f"Device not found: {device}"}
            else:
                device_id = None
            
            # Search for content based on type
            if music_type == "track":
                tracks = self.spotify_client.search_track(query, limit=1)
                if tracks:
                    success = self.spotify_client.play_track(tracks[0]['uri'], device_id)
                else:
                    return {"success": False, "error": f"No tracks found for: {query}"}
            else:
                # For now, just try to resume playback
                success = self.spotify_client.resume(device_id)
            
            if success:
                return {
                    "success": True,
                    "message": f"Playing {query} on {device or 'default device'}"
                }
            else:
                return {"success": False, "error": "Failed to play music"}
                
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _pause_music(self, task: Task) -> Dict[str, Any]:
        """Pause music"""
        if not self.spotify_client:
            return {"success": False, "error": "Spotify not configured"}
        
        device = task.parameters.get("device", "")
        device_id = None
        
        if device:
            device_obj = self.spotify_client.find_device_by_name(device)
            if device_obj:
                device_id = device_obj['id']
        
        try:
            success = self.spotify_client.pause(device_id)
            if success:
                return {"success": True, "message": "Music paused"}
            else:
                return {"success": False, "error": "Failed to pause music"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _resume_music(self, task: Task) -> Dict[str, Any]:
        """Resume music"""
        if not self.spotify_client:
            return {"success": False, "error": "Spotify not configured"}
        
        device = task.parameters.get("device", "")
        device_id = None
        
        if device:
            device_obj = self.spotify_client.find_device_by_name(device)
            if device_obj:
                device_id = device_obj['id']
        
        try:
            success = self.spotify_client.resume(device_id)
            if success:
                return {"success": True, "message": "Music resumed"}
            else:
                return {"success": False, "error": "Failed to resume music"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _set_volume(self, task: Task) -> Dict[str, Any]:
        """Set volume"""
        volume = task.parameters.get("volume", 50)
        device = task.parameters.get("device", "")
        
        try:
            if self.spotify_client and device:
                device_obj = self.spotify_client.find_device_by_name(device)
                if device_obj:
                    success = self.spotify_client.set_volume(volume, device_obj['id'])
                    if success:
                        return {"success": True, "message": f"Volume set to {volume}%"}
                    else:
                        return {"success": False, "error": "Failed to set volume"}
                else:
                    return {"success": False, "error": f"Device not found: {device}"}
            else:
                return {"success": False, "error": "Spotify not configured or device not specified"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def get_execution_history(self, limit: int = 10) -> List[Dict]:
        """Get recent execution history"""
        return self.execution_history[-limit:] if self.execution_history else []
    
    def clear_history(self):
        """Clear execution history"""
        self.execution_history.clear()
        logger.info("Execution history cleared") 