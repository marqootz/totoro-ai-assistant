<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Expression System - Big Hero 6 Style Avatar (High Quality)</title>
    
    <!-- Core Libraries (no SocketIO) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flubber@0.4.2/build/flubber.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sentiment@5.0.2/build/sentiment.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .demo-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
        }

        .title {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 40px;
            font-size: 1.1em;
        }

        .avatar-container {
            display: flex;
            justify-content: center;
            margin-bottom: 40px;
            width: 100%; /* Full width container */
            max-width: 800px; /* Match demo container max-width */
        }

        #avatarContainer {
            width: 400px;
            height: 300px;
            min-width: 400px;  /* Prevent shrinking */
            max-width: 400px;  /* Prevent growing */
            min-height: 300px; /* Prevent shrinking */
            max-height: 300px; /* Prevent growing */
            border-radius: 20px;
            background: linear-gradient(145deg, #f0f0f0, #e6e6e6);
            border: 3px solid #e9ecef;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 2px 4px rgba(255,255,255,0.8),
                inset 0 -2px 4px rgba(0,0,0,0.1),
                0 8px 16px rgba(0,0,0,0.1);
            flex-shrink: 0; /* Prevent flexbox from shrinking this */
        }

        .avatar-face {
            width: 400px;    /* Fixed width */
            height: 300px;   /* Fixed height */
            max-width: 100%;
            max-height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .emotion-btn {
            background: #3498db;
            color: white;
        }

        .emotion-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .emotion-btn.active {
            background: #e74c3c;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .settings-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .settings-title {
            font-size: 1.2em;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .setting-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 25px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 25px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 19px;
            width: 19px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #3498db;
        }

        input:checked + .slider:before {
            transform: translateX(25px);
        }

        .text-input-section {
            margin-bottom: 20px;
        }

        .text-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 16px;
            margin-bottom: 10px;
            transition: border-color 0.3s ease;
        }

        .text-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .analyze-btn {
            background: #27ae60;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: background 0.3s ease;
        }

        .analyze-btn:hover {
            background: #229954;
        }

        .demo-text-samples {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .sample-btn {
            background: #f39c12;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .sample-btn:hover {
            background: #e67e22;
        }

        .performance-metrics {
            background: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #34495e;
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .status-indicator {
            text-align: center;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 8px;
            background: #27ae60;
            color: white;
            font-weight: 600;
        }

        .api-status {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }

        .quality-indicator {
            text-align: center;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 6px;
            background: #3498db;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <h1 class="title">üé≠ Big Hero 6 Expression System</h1>
        <p class="subtitle">High-Quality Fluid Avatar Expressions with Real-time Sentiment Analysis</p>
        
        <div class="status-indicator" id="statusIndicator">
            <div>‚úÖ System Running in High Quality Mode</div>
            <div class="api-status" id="apiStatus">Connecting to server...</div>
            <div class="api-status" id="audioStatus" style="display: none;">üé§ Real-time Audio Lip Sync Active</div>
        </div>
        
        <div class="quality-indicator">
            üé® High Resolution SVG ‚Ä¢ Smooth Morphing ‚Ä¢ Enhanced Gradients ‚Ä¢ 60fps Target
        </div>
        
        <div class="avatar-container">
            <div id="avatarContainer"></div>
        </div>
        
        <div class="controls">
            <button class="control-button emotion-btn" onclick="setEmotion('neutral')">üòê Neutral</button>
            <button class="control-button emotion-btn active" onclick="setEmotion('idle')">üòå Idle</button>
            <button class="control-button emotion-btn" onclick="setEmotion('happy')">üòä Happy</button>
            <button class="control-button emotion-btn" onclick="setEmotion('sad')">üò¢ Sad</button>
            <button class="control-button emotion-btn" onclick="setEmotion('surprised')">üò≤ Surprised</button>
            <button class="control-button emotion-btn" onclick="setEmotion('thinking')">ü§î Thinking</button>
            <button class="control-button emotion-btn" onclick="setEmotion('speaking')">üó£Ô∏è Speaking</button>
            <button class="control-button emotion-btn" onclick="setEmotion('confused')">üòï Confused</button>
            <button class="control-button emotion-btn" onclick="setEmotion('determined')">üò§ Determined</button>
            <button class="control-button emotion-btn" onclick="setEmotion('concerned')">üòü Concerned</button>
            <button class="control-button emotion-btn" onclick="setEmotion('amazed')">ü§© Amazed</button>
            <button class="control-button emotion-btn" onclick="setEmotion('skeptical')">ü§® Skeptical</button>
            <button class="control-button emotion-btn" onclick="setEmotion('ecstatic')">ü•≥ Ecstatic</button>
        </div>
        
        <div class="settings-section">
            <h3 class="settings-title">‚öôÔ∏è System Settings</h3>
            <div class="setting-item">
                <span>Real-time Sentiment Analysis</span>
                <label class="toggle">
                    <input type="checkbox" id="sentimentToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span>Performance Monitoring</span>
                <label class="toggle">
                    <input type="checkbox" id="performanceToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span>High Quality Rendering</span>
                <label class="toggle">
                    <input type="checkbox" id="qualityToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span>üé§ Real-time Audio Lip Sync</span>
                <label class="toggle">
                    <input type="checkbox" id="audioLipSyncToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        
        <div class="text-input-section">
            <input type="text" class="text-input" id="textInput" 
                   placeholder="Enter text to analyze sentiment and trigger expressions...">
            <button class="analyze-btn" onclick="analyzeText()">Analyze Sentiment</button>
            <button class="analyze-btn" onclick="fetchServerSentiment()">Send to Server</button>
            
            <div class="demo-text-samples">
                <button class="sample-btn" onclick="analyzePresetText('I am so excited about this new feature!')">üòä Happy Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('This is really disappointing and frustrating.')">üò¢ Sad Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('Wow, I never expected that to happen!')">üò≤ Surprised Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('Let me think about this carefully...')">ü§î Thinking Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('I am confused about what you mean.')">üòï Confused Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('I am determined to make this work!')">üò§ Determined Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('I am worried this might not work out.')">üòü Concerned Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('This is absolutely incredible and fantastic!')">ü§© Amazed Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('Hmm, I doubt that is really true.')">ü§® Skeptical Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('This is the most amazing thing ever!')">ü•≥ Ecstatic Sample</button>
            </div>
        </div>
        
        <div class="performance-metrics" id="performanceMetrics" style="display: none;">
            <div class="metric-row">
                <span>FPS:</span>
                <span id="fpsMetric">--</span>
            </div>
            <div class="metric-row">
                <span>Current Emotion:</span>
                <span id="emotionMetric">neutral</span>
            </div>
            <div class="metric-row">
                <span>Queue Length:</span>
                <span id="queueMetric">0</span>
            </div>
            <div class="metric-row">
                <span>Animation Frames:</span>
                <span id="framesMetric">0</span>
            </div>
            <div class="metric-row">
                <span>Render Quality:</span>
                <span id="qualityMetric">High</span>
            </div>
        </div>
    </div>

    <script>
        // High Quality Expression System (Enhanced Version)
        class HighQualityExpressionSystem {
            constructor(containerId, options = {}) {
                this.container = document.getElementById(containerId);
                this.options = {
                    enableSentimentAnalysis: true,
                    animationDuration: 200,
                    highQuality: true,
                    ...options
                };
                
                this.currentEmotion = 'idle';
                this.isAnimating = false;
                
                this.init();
            }

            init() {
                this.createHighQualitySVGStructure();
                this.setupEnhancedExpressionPaths();
                this.initializeAnimationSystem();
                this.setupPerformanceMonitoring();
                this.checkServerStatus();
            }

            createHighQualitySVGStructure() {
                // Create high-resolution SVG based on original h1ro.svg design
                this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                this.svg.setAttribute('viewBox', '0 0 400 300'); // Adjusted for h1ro proportions
                this.svg.setAttribute('width', '400');
                this.svg.setAttribute('height', '300');
                this.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                this.svg.classList.add('avatar-face');
                this.svg.style.shapeRendering = 'geometricPrecision';
                this.svg.style.textRendering = 'optimizeLegibility';
                this.svg.style.overflow = 'visible';
                this.svg.style.display = 'block';
                
                // Create definitions for gradients and filters
                this.createSVGDefinitions();
                
                this.faceGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.faceGroup.classList.add('face-group');
                this.faceGroup.style.transformOrigin = '200px 150px'; // Center of 400x300 viewBox
                
                // Head with h1ro styling (oval shape)
                this.head = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.head.setAttribute('fill', '#D9D9D9');
                this.head.setAttribute('stroke', '#bbb');
                this.head.setAttribute('stroke-width', '1');
                this.head.setAttribute('filter', 'url(#headGlow)');
                this.head.style.transformOrigin = '200px 120px'; // Center of head shape
                
                // Eyes with h1ro styling (perfect circles)
                this.leftEye = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                this.leftEye.setAttribute('fill', '#000000');
                this.leftEye.setAttribute('filter', 'url(#eyeShadow)');
                this.leftEye.style.transformOrigin = '105px 120px'; // Center of left eye
                
                this.rightEye = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                this.rightEye.setAttribute('fill', '#000000');
                this.rightEye.setAttribute('filter', 'url(#eyeShadow)');
                this.rightEye.style.transformOrigin = '295px 120px'; // Center of right eye
                
                // Mouth (replaces bridge) - oval shape like original h1ro
                this.mouth = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                this.mouth.setAttribute('fill', '#000000');
                this.mouth.setAttribute('filter', 'url(#mouthGlow)');
                this.mouth.style.transformOrigin = '200px 180px'; // Center of mouth area
                
                // Assemble SVG
                this.faceGroup.appendChild(this.head);
                this.faceGroup.appendChild(this.leftEye);
                this.faceGroup.appendChild(this.rightEye);
                this.faceGroup.appendChild(this.mouth);
                this.svg.appendChild(this.faceGroup);
                this.container.appendChild(this.svg);
            }

            createSVGDefinitions() {
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                
                // Face gradient
                const faceGradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                faceGradient.setAttribute('id', 'faceGradient');
                faceGradient.setAttribute('cx', '50%');
                faceGradient.setAttribute('cy', '40%');
                faceGradient.setAttribute('r', '60%');
                
                const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop1.setAttribute('offset', '0%');
                stop1.setAttribute('stop-color', '#ffffff');
                stop1.setAttribute('stop-opacity', '0.9');
                
                const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop2.setAttribute('offset', '100%');
                stop2.setAttribute('stop-color', '#ecf0f1');
                stop2.setAttribute('stop-opacity', '1');
                
                faceGradient.appendChild(stop1);
                faceGradient.appendChild(stop2);
                
                // Drop shadow filter
                const dropShadow = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                dropShadow.setAttribute('id', 'dropShadow');
                dropShadow.setAttribute('x', '-50%');
                dropShadow.setAttribute('y', '-50%');
                dropShadow.setAttribute('width', '200%');
                dropShadow.setAttribute('height', '200%');
                
                const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'feDropShadow');
                shadow.setAttribute('dx', '0');
                shadow.setAttribute('dy', '2');
                shadow.setAttribute('stdDeviation', '2');
                shadow.setAttribute('flood-color', '#000000');
                shadow.setAttribute('flood-opacity', '0.2');
                
                dropShadow.appendChild(shadow);
                
                // Eye shadow filter
                const eyeShadow = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                eyeShadow.setAttribute('id', 'eyeShadow');
                
                const eyeShadowEffect = document.createElementNS('http://www.w3.org/2000/svg', 'feDropShadow');
                eyeShadowEffect.setAttribute('dx', '0');
                eyeShadowEffect.setAttribute('dy', '1');
                eyeShadowEffect.setAttribute('stdDeviation', '1');
                eyeShadowEffect.setAttribute('flood-color', '#000000');
                eyeShadowEffect.setAttribute('flood-opacity', '0.3');
                
                eyeShadow.appendChild(eyeShadowEffect);
                
                // Mouth glow filter
                const mouthGlow = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                mouthGlow.setAttribute('id', 'mouthGlow');
                
                const glow = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
                glow.setAttribute('stdDeviation', '1');
                glow.setAttribute('result', 'coloredBlur');
                
                const merge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
                const mergeNode1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                mergeNode1.setAttribute('in', 'coloredBlur');
                const mergeNode2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                mergeNode2.setAttribute('in', 'SourceGraphic');
                
                merge.appendChild(mergeNode1);
                merge.appendChild(mergeNode2);
                mouthGlow.appendChild(glow);
                mouthGlow.appendChild(merge);
                
                defs.appendChild(faceGradient);
                defs.appendChild(dropShadow);
                defs.appendChild(eyeShadow);
                defs.appendChild(mouthGlow);
                this.svg.appendChild(defs);
            }

            setupEnhancedExpressionPaths() {
                // H1RO-style avatar expressions with authentic mouth shapes and phonemes
                // Base expressions that will be varied generatively
                this.baseExpressions = {
                    neutral: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 120, r: 16 },
                        rightEye: { cx: 295, cy: 120, r: 16 },
                        mouth: { cx: 200, cy: 180, rx: 20, ry: 4 }, // Neutral closed mouth
                        headRotation: 0
                    },
                    idle: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 120, r: 16 },
                        rightEye: { cx: 295, cy: 120, r: 16 },
                        mouth: { cx: 200, cy: 180, rx: 18, ry: 3 }, // Slightly relaxed mouth
                        headRotation: 0
                    },
                    happy: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 115, r: 12 }, // Squinted with joy
                        rightEye: { cx: 295, cy: 115, r: 12 },
                        mouth: { cx: 200, cy: 185, rx: 25, ry: 12 }, // Smiling open mouth
                        headRotation: 5
                    },
                    sad: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 102, cy: 125, r: 18 }, // Droopy, larger
                        rightEye: { cx: 292, cy: 125, r: 18 },
                        mouth: { cx: 200, cy: 190, rx: 15, ry: 6 }, // Downturned mouth
                        headRotation: -8
                    },
                    surprised: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 118, r: 22 }, // Wide open
                        rightEye: { cx: 295, cy: 118, r: 22 },
                        mouth: { cx: 200, cy: 185, rx: 12, ry: 18 }, // Open "O" shape
                        headRotation: 2
                    },
                    thinking: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 122, r: 14 }, // Focused, smaller
                        rightEye: { cx: 295, cy: 122, r: 14 },
                        mouth: { cx: 200, cy: 182, rx: 8, ry: 3 }, // Small contemplative mouth
                        headRotation: -5
                    },
                    speaking: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 119, r: 15 }, // Engaged
                        rightEye: { cx: 295, cy: 119, r: 15 },
                        mouth: { cx: 200, cy: 184, rx: 18, ry: 10 }, // Active speaking mouth
                        headRotation: 3
                    },
                    confused: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 104, cy: 121, r: 15 }, // Asymmetrical confusion
                        rightEye: { cx: 296, cy: 119, r: 17 },
                        mouth: { cx: 200, cy: 183, rx: 6, ry: 8 }, // Small confused "o"
                        headRotation: -2
                    },
                    determined: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 118, r: 13 }, // Narrowed focus
                        rightEye: { cx: 295, cy: 118, r: 13 },
                        mouth: { cx: 200, cy: 182, rx: 22, ry: 3 }, // Tight determined line
                        headRotation: 4
                    },
                    concerned: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 103, cy: 123, r: 17 }, // Worried, closer together
                        rightEye: { cx: 293, cy: 123, r: 17 },
                        mouth: { cx: 200, cy: 188, rx: 14, ry: 8 }, // Worried frown
                        headRotation: -6
                    },
                    amazed: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 117, r: 24 }, // Very wide, wonder-filled
                        rightEye: { cx: 295, cy: 117, r: 24 },
                        mouth: { cx: 200, cy: 185, rx: 15, ry: 20 }, // Large amazed "O"
                        headRotation: 4
                    },
                    skeptical: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 103, cy: 119, r: 14 }, // Asymmetrical doubt
                        rightEye: { cx: 297, cy: 121, r: 16 },
                        mouth: { cx: 200, cy: 183, rx: 18, ry: 4 }, // Slight smirk
                        headRotation: -3
                    },
                    ecstatic: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 112, r: 10 }, // Very squinted with extreme joy
                        rightEye: { cx: 295, cy: 112, r: 10 },
                        mouth: { cx: 200, cy: 188, rx: 30, ry: 15 }, // Wide ecstatic smile
                        headRotation: 8
                    }
                };
                
                // Enhanced phoneme mouth shapes for realistic speaking (based on professional systems)
                this.phonemeMouths = {
                    // Bilabial sounds - lips together
                    closed: { cx: 200, cy: 180, rx: 20, ry: 2 }, // m, b, p
                    
                    // Fricatives and sibilants  
                    small_open: { cx: 200, cy: 182, rx: 8, ry: 6 }, // s, c, z, sh, ch, f, v
                    teeth_lower: { cx: 200, cy: 181, rx: 12, ry: 4 }, // f, v (teeth on lower lip)
                    
                    // Mid vowels and consonants
                    medium_open: { cx: 200, cy: 184, rx: 15, ry: 10 }, // d, t, n, l
                    
                    // Open vowels
                    wide_open: { cx: 200, cy: 186, rx: 18, ry: 14 }, // ah, o, aw
                    very_wide: { cx: 200, cy: 188, rx: 22, ry: 18 }, // aa (father)
                    
                    // Rounded vowels
                    round_small: { cx: 200, cy: 182, rx: 10, ry: 10 }, // oo (book), u (put)
                    round_medium: { cx: 200, cy: 184, rx: 14, ry: 14 }, // o (boat), oo (boot)
                    
                    // High vowels
                    tall_narrow: { cx: 200, cy: 183, rx: 8, ry: 16 }, // ee (beat), i (bit)
                    tall_open: { cx: 200, cy: 185, rx: 12, ry: 20 }, // eh (bet), ae (bat)
                    
                    // Consonant clusters
                    tongue_tip: { cx: 200, cy: 182, rx: 10, ry: 6 }, // th, l, r
                    tongue_back: { cx: 200, cy: 185, rx: 16, ry: 12 }, // k, g, ng
                    
                    // Aspirated and glottal
                    aspirated: { cx: 200, cy: 184, rx: 14, ry: 8 }, // h, wh
                    glottal: { cx: 200, cy: 183, rx: 6, ry: 4 }, // glottal stop
                    
                    // Diphthongs - transitional shapes
                    diphthong_start: { cx: 200, cy: 184, rx: 16, ry: 12 }, // ay, oy, ow (start)
                    diphthong_end: { cx: 200, cy: 182, rx: 10, ry: 8 }, // ay, oy, ow (end)
                    
                    // Rest position
                    rest: { cx: 200, cy: 180, rx: 18, ry: 3 }
                };
                
                // Generate current expressions with variations
                this.generateExpressionVariations();
            }

            generateExpressionVariations() {
                this.expressions = {};
                
                Object.keys(this.baseExpressions).forEach(emotion => {
                    const base = this.baseExpressions[emotion];
                    
                    // Add small random variations while preserving emotion
                    const variation = {
                        head: base.head,
                        leftEye: {
                            cx: base.leftEye.cx + this.randomVariation(2), 
                            cy: base.leftEye.cy + this.randomVariation(1), 
                            r: Math.max(5, base.leftEye.r + this.randomVariation(1))
                        },
                        rightEye: {
                            cx: base.rightEye.cx + this.randomVariation(2), 
                            cy: base.rightEye.cy + this.randomVariation(1), 
                            r: Math.max(5, base.rightEye.r + this.randomVariation(1))
                        },
                        mouth: {
                            cx: base.mouth.cx + this.randomVariation(1), 
                            cy: base.mouth.cy + this.randomVariation(0.5), 
                            rx: Math.max(3, base.mouth.rx + this.randomVariation(0.5)), 
                            ry: Math.max(1, base.mouth.ry + this.randomVariation(0.5))
                        },
                        headRotation: base.headRotation + this.randomVariation(0.5)
                    };
                    
                    this.expressions[emotion] = variation;
                });
            }

            randomVariation(maxRange) {
                return (Math.random() - 0.5) * 2 * maxRange;
            }

            initializeAnimationSystem() {
                this.setInitialPaths();
                this.setupMorphingAnimations();
            }

            setInitialPaths() {
                const idle = this.expressions.idle;
                this.head.setAttribute('d', idle.head);
                this.leftEye.setAttribute('cx', idle.leftEye.cx);
                this.leftEye.setAttribute('cy', idle.leftEye.cy);
                this.leftEye.setAttribute('r', idle.leftEye.r);
                this.rightEye.setAttribute('cx', idle.rightEye.cx);
                this.rightEye.setAttribute('cy', idle.rightEye.cy);
                this.rightEye.setAttribute('r', idle.rightEye.r);
                this.mouth.setAttribute('cx', idle.mouth.cx);
                this.mouth.setAttribute('cy', idle.mouth.cy);
                this.mouth.setAttribute('rx', idle.mouth.rx);
                this.mouth.setAttribute('ry', idle.mouth.ry);
            }

            setupMorphingAnimations() {
                this.morphFunctions = {};
                
                Object.keys(this.expressions).forEach(emotion => {
                    this.morphFunctions[emotion] = {};
                    const paths = this.expressions[emotion];
                    
                    // Only setup morphing for head (path) - eyes and mouth use GSAP attribute animation
                    ['head'].forEach(element => {
                        this.morphFunctions[emotion][element] = {};
                        
                        Object.keys(this.expressions).forEach(targetEmotion => {
                            if (emotion !== targetEmotion) {
                                try {
                                    this.morphFunctions[emotion][element][targetEmotion] = 
                                        flubber.interpolate(paths[element], this.expressions[targetEmotion][element]);
                                } catch (e) {
                                    console.warn(`Failed to create morph from ${emotion} to ${targetEmotion} for ${element}`);
                                }
                            }
                        });
                    });
                });
            }

            setExpression(emotion, immediate = false) {
                if (immediate) {
                    this.setImmediateExpression(emotion);
                } else {
                    this.transitionToExpression(emotion);
                }
            }

            setImmediateExpression(emotion) {
                if (!this.expressions[emotion]) return;
                
                const paths = this.expressions[emotion];
                this.head.setAttribute('d', paths.head);
                this.leftEye.setAttribute('cx', paths.leftEye.cx);
                this.leftEye.setAttribute('cy', paths.leftEye.cy);
                this.leftEye.setAttribute('r', paths.leftEye.r);
                this.rightEye.setAttribute('cx', paths.rightEye.cx);
                this.rightEye.setAttribute('cy', paths.rightEye.cy);
                this.rightEye.setAttribute('r', paths.rightEye.r);
                this.mouth.setAttribute('cx', paths.mouth.cx);
                this.mouth.setAttribute('cy', paths.mouth.cy);
                this.mouth.setAttribute('rx', paths.mouth.rx);
                this.mouth.setAttribute('ry', paths.mouth.ry);
                
                this.currentEmotion = emotion;
            }

            transitionToExpression(emotion) {
                if (emotion === this.currentEmotion || this.isAnimating) return;
                
                this.isAnimating = true;
                const duration = this.options.animationDuration;
                
                // Regenerate expressions with slight variations each time
                this.generateExpressionVariations();
                
                const timeline = gsap.timeline({
                    onComplete: () => {
                        this.currentEmotion = emotion;
                        this.isAnimating = false;
                    }
                });
                
                // Get target expression
                const targetExpression = this.expressions[emotion];
                
                // Animate head rotation
                timeline.to(this.head, {
                    duration: duration / 1000 * 2,
                    rotation: targetExpression.headRotation,
                    ease: "cubic-bezier(0, 0, 0.58, 1)",
                    transformOrigin: "center center"
                }, 0);
                
                // Animate head morphing
                const headMorphFunction = this.morphFunctions[this.currentEmotion]?.head?.[emotion];
                if (headMorphFunction) {
                    timeline.to({}, {
                        duration: duration / 1000 * 2,
                        ease: "cubic-bezier(0, 0, 0.58, 1)",
                        onUpdate: function() {
                            const progress = this.progress();
                            const newPath = headMorphFunction(progress);
                            this.targets()[0].head.setAttribute('d', newPath);
                        }.bind({head: this.head})
                    }, 0);
                }
                
                // Animate left eye
                timeline.to(this.leftEye, {
                    duration: duration / 1000 * 2,
                    attr: {
                        cx: targetExpression.leftEye.cx,
                        cy: targetExpression.leftEye.cy,
                        r: targetExpression.leftEye.r
                    },
                    ease: "cubic-bezier(0, 0, 0.58, 1)"
                }, 0);
                
                // Animate right eye
                timeline.to(this.rightEye, {
                    duration: duration / 1000 * 2,
                    attr: {
                        cx: targetExpression.rightEye.cx,
                        cy: targetExpression.rightEye.cy,
                        r: targetExpression.rightEye.r
                    },
                    ease: "cubic-bezier(0, 0, 0.58, 1)"
                }, 0);
                
                // Animate mouth
                timeline.to(this.mouth, {
                    duration: duration / 1000 * 2,
                    attr: {
                        cx: targetExpression.mouth.cx,
                        cy: targetExpression.mouth.cy,
                        rx: targetExpression.mouth.rx,
                        ry: targetExpression.mouth.ry
                    },
                    ease: "cubic-bezier(0, 0, 0.58, 1)"
                }, 0);
                
                // Add subtle scaling animation for eyes and mouth
                [this.leftEye, this.rightEye, this.mouth].forEach((element, index) => {
                    timeline.to(element, {
                        duration: duration / 1000,
                        scale: 1.05,
                        ease: "cubic-bezier(0, 0, 0.58, 1)",
                        transformOrigin: "center center"
                    }, index * 0.005);
                    
                    timeline.to(element, {
                        duration: duration / 1000,
                        scale: 1.0,
                        ease: "cubic-bezier(0, 0, 0.58, 1)",
                        transformOrigin: "center center"
                    }, duration / 1000 + index * 0.005);
                });
            }

            analyzeSentiment(text) {
                if (typeof Sentiment !== 'undefined') {
                    const sentiment = new Sentiment();
                    const result = sentiment.analyze(text);
                    const emotion = this.determineEmotion(result);
                    const confidence = Math.abs(result.score) / Math.max(text.split(' ').length, 1);
                    
                    if (confidence > 0.3) {
                        this.setExpression(emotion);
                    }
                    
                    return { emotion, confidence, result };
                }
                return null;
            }

            determineEmotion(sentimentResult) {
                const score = sentimentResult.score;
                const comparative = sentimentResult.comparative;
                const tokens = sentimentResult.tokens.map(t => t.toLowerCase());
                
                // Check for specific emotional keywords first
                if (tokens.some(token => ['amazing', 'incredible', 'fantastic', 'awesome'].includes(token))) {
                    return Math.random() > 0.5 ? 'amazed' : 'ecstatic';
                }
                
                if (tokens.some(token => ['confused', 'puzzled', 'unclear', 'what', 'huh'].includes(token))) {
                    return 'confused';
                }
                
                if (tokens.some(token => ['determined', 'focused', 'will', 'must', 'definitely'].includes(token))) {
                    return 'determined';
                }
                
                if (tokens.some(token => ['worried', 'concerned', 'anxious', 'nervous'].includes(token))) {
                    return 'concerned';
                }
                
                if (tokens.some(token => ['skeptical', 'doubt', 'really', 'sure', 'hmm'].includes(token))) {
                    return 'skeptical';
                }
                
                // Enhanced sentiment-based emotion detection
                if (score > 5) return 'ecstatic';
                if (score > 3) return 'happy';
                if (score > 1) return Math.random() > 0.5 ? 'happy' : 'amazed';
                
                if (score < -5) return Math.random() > 0.5 ? 'sad' : 'concerned';
                if (score < -3) return 'sad';
                if (score < -1) return Math.random() > 0.5 ? 'sad' : 'concerned';
                
                if (Math.abs(comparative) > 0.5) return 'surprised';
                if (Math.abs(comparative) > 0.3) return Math.random() > 0.5 ? 'surprised' : 'amazed';
                
                if (tokens.some(token => 
                    ['think', 'consider', 'maybe', 'perhaps', 'wondering', 'hmm'].includes(token)
                )) {
                    return Math.random() > 0.5 ? 'thinking' : 'confused';
                }
                
                return 'neutral';
            }

            setupPerformanceMonitoring() {
                this.performanceMetrics = {
                    animationFrames: 0,
                    lastFrameTime: performance.now(),
                    avgFrameTime: 16.67
                };
                
                this.startPerformanceMonitoring();
            }

            startPerformanceMonitoring() {
                const monitor = () => {
                    const currentTime = performance.now();
                    const frameTime = currentTime - this.performanceMetrics.lastFrameTime;
                    
                    this.performanceMetrics.avgFrameTime = 
                        (this.performanceMetrics.avgFrameTime * 0.9) + (frameTime * 0.1);
                    
                    this.performanceMetrics.lastFrameTime = currentTime;
                    this.performanceMetrics.animationFrames++;
                    
                    requestAnimationFrame(monitor);
                };
                
                requestAnimationFrame(monitor);
            }

            checkServerStatus() {
                fetch('/api/status')
                    .then(response => response.json())
                    .then(data => {
                        const statusEl = document.getElementById('apiStatus');
                        statusEl.textContent = `‚úÖ Connected to ${data.server_type || 'server'} - Mode: ${data.demo_mode ? 'Demo' : 'Production'}`;
                    })
                    .catch(error => {
                        const statusEl = document.getElementById('apiStatus');
                        statusEl.textContent = '‚ö†Ô∏è Server connection failed';
                    });
            }

            getPerformanceMetrics() {
                return {
                    ...this.performanceMetrics,
                    fps: 1000 / this.performanceMetrics.avgFrameTime,
                    currentEmotion: this.currentEmotion,
                    queueLength: 0,
                    quality: this.options.highQuality ? 'High' : 'Standard'
                };
            }

            // Add phoneme animation for realistic speaking
            animatePhonemes(text) {
                if (!text) return;
                
                // Simple phoneme mapping based on text
                const phonemes = this.textToPhonemes(text);
                const timeline = gsap.timeline();
                
                phonemes.forEach((phoneme, index) => {
                    const mouthShape = this.phonemeMouths[phoneme] || this.phonemeMouths.medium_open;
                    
                    timeline.to(this.mouth, {
                        duration: 0.15,
                        attr: {
                            cx: mouthShape.cx,
                            cy: mouthShape.cy,
                            rx: mouthShape.rx,
                            ry: mouthShape.ry
                        },
                        ease: "power2.out"
                    }, index * 0.1);
                });
                
                // Return to speaking mouth shape
                timeline.to(this.mouth, {
                    duration: 0.2,
                    attr: {
                        cx: this.expressions.speaking.mouth.cx,
                        cy: this.expressions.speaking.mouth.cy,
                        rx: this.expressions.speaking.mouth.rx,
                        ry: this.expressions.speaking.mouth.ry
                    },
                    ease: "power2.out"
                });
            }
            
            textToPhonemes(text) {
                // Enhanced phoneme mapping with co-articulation consideration
                const phonemeMap = {
                    // Bilabials
                    'b': 'closed', 'm': 'closed', 'p': 'closed',
                    
                    // Fricatives and Sibilants  
                    's': 'small_open', 'z': 'small_open', 'sh': 'small_open', 
                    'ch': 'small_open', 'j': 'small_open',
                    'f': 'teeth_lower', 'v': 'teeth_lower',
                    
                    // Alveolars
                    'd': 'medium_open', 't': 'medium_open', 'n': 'medium_open',
                    
                    // Liquids
                    'l': 'tongue_tip', 'r': 'tongue_tip',
                    
                    // Fricatives
                    'th': 'tongue_tip', // both voiced and unvoiced
                    
                    // Velars
                    'k': 'tongue_back', 'g': 'tongue_back', 'ng': 'tongue_back',
                    
                    // Glottals and Aspirated
                    'h': 'aspirated', 'wh': 'aspirated',
                    
                    // Vowels - High
                    'i': 'tall_narrow', 'ee': 'tall_narrow', 
                    'ih': 'tall_open', 'eh': 'tall_open',
                    
                    // Vowels - Mid
                    'e': 'medium_open', 'uh': 'medium_open',
                    'er': 'medium_open', 'ur': 'medium_open',
                    
                    // Vowels - Low  
                    'a': 'wide_open', 'ah': 'wide_open', 'o': 'wide_open',
                    'aa': 'very_wide', 'aw': 'very_wide',
                    
                    // Rounded vowels
                    'u': 'round_small', 'oo': 'round_medium', 
                    'w': 'round_medium',
                    
                    // Diphthongs
                    'ay': 'diphthong_start', 'oy': 'diphthong_start', 
                    'ow': 'diphthong_start', 'ey': 'diphthong_start'
                };
                
                // Simple word-to-phoneme mapping for common words
                const wordPhonemes = {
                    'the': ['th', 'uh'],
                    'and': ['ah', 'n', 'd'],
                    'hello': ['h', 'eh', 'l', 'ow'],
                    'world': ['w', 'er', 'l', 'd'],
                    'how': ['h', 'ow'],
                    'are': ['ah', 'r'],
                    'you': ['y', 'oo'],
                    'what': ['wh', 'ah', 't'],
                    'when': ['wh', 'eh', 'n'],
                    'where': ['wh', 'eh', 'r'],
                    'this': ['th', 'ih', 's'],
                    'that': ['th', 'ah', 't'],
                    'with': ['w', 'ih', 'th'],
                    'will': ['w', 'ih', 'l'],
                    'can': ['k', 'ah', 'n'],
                    'could': ['k', 'oo', 'd'],
                    'should': ['sh', 'oo', 'd'],
                    'would': ['w', 'oo', 'd']
                };
                
                const phonemes = [];
                const words = text.toLowerCase().split(/\s+/);
                
                for (let word of words) {
                    // Clean word of punctuation
                    const cleanWord = word.replace(/[^\w]/g, '');
                    
                    if (wordPhonemes[cleanWord]) {
                        // Use pre-mapped phonemes for known words
                        phonemes.push(...wordPhonemes[cleanWord]);
                    } else {
                        // Fall back to character-based mapping
                        for (let char of cleanWord) {
                            phonemes.push(phonemeMap[char] || 'medium_open');
                        }
                    }
                    
                    // Add brief pause between words
                    if (words.indexOf(word) < words.length - 1) {
                        phonemes.push('rest');
                    }
                }
                
                return phonemes;
            }
        }

        // Global variables
        let expressionSystem;
        let performanceInterval;
        let audioProcessor; // New audio processing system
        
        // Audio processing class for real-time lip sync
        class RealTimeAudioProcessor {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.isListening = false;
                this.dataArray = null;
                this.bufferLength = 0;
                this.lastPhoneme = 'rest';
                this.phonemeThresholds = this.setupPhonemeThresholds();
                this.smoothingFactor = 0.8; // For performance, less smoothing
                this.detectedPhonemes = new Set(); // Track unique phonemes detected
            }
            
            setupPhonemeThresholds() {
                // Frequency-based phoneme detection (fast, no ML needed)
                return {
                    // High frequency energy (2000-8000 Hz) - sibilants
                    sibilant: { minFreq: 2000, maxFreq: 8000, threshold: 0.3 },
                    // Mid frequency energy (500-2000 Hz) - vowels  
                    vowel: { minFreq: 500, maxFreq: 2000, threshold: 0.4 },
                    // Low frequency energy (80-500 Hz) - voiced sounds
                    voiced: { minFreq: 80, maxFreq: 500, threshold: 0.5 },
                    // Very low energy - closed sounds
                    closed: { minFreq: 0, maxFreq: 300, threshold: 0.2 }
                };
            }
            
            async startListening() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { 
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 16000 // Lower sample rate for performance
                        } 
                    });
                    
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.analyser = this.audioContext.createAnalyser();
                    
                    // Optimize for performance
                    this.analyser.fftSize = 512; // Smaller FFT for speed
                    this.analyser.smoothingTimeConstant = this.smoothingFactor;
                    
                    this.bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(this.bufferLength);
                    
                    this.microphone.connect(this.analyser);
                    this.isListening = true;
                    
                    this.processAudio();
                    console.log('Real-time audio processing started');
                    
                } catch (error) {
                    console.error('Error starting audio:', error);
                }
            }
            
            processAudio() {
                if (!this.isListening) return;
                
                this.analyser.getByteFrequencyData(this.dataArray);
                
                // Fast phoneme detection based on frequency analysis
                const phoneme = this.detectPhoneme(this.dataArray);
                
                if (phoneme !== this.lastPhoneme) {
                    this.updateMouthShape(phoneme);
                    this.lastPhoneme = phoneme;
                }
                
                // High frequency processing for real-time feel
                requestAnimationFrame(() => this.processAudio());
            }
            
            detectPhoneme(frequencyData) {
                // Enhanced frequency analysis with more bands for better phoneme detection
                const sampleRate = this.audioContext.sampleRate;
                const binSize = sampleRate / this.analyser.fftSize;
                
                // More sophisticated frequency band analysis
                let veryHighEnergy = 0;    // 4000-8000 Hz - sibilants (s, sh, ch)
                let highEnergy = 0;        // 2000-4000 Hz - fricatives (f, v, th)
                let midHighEnergy = 0;     // 1000-2000 Hz - high vowels (ee, i)
                let midEnergy = 0;         // 500-1000 Hz - mid vowels (eh, e)
                let lowMidEnergy = 0;      // 250-500 Hz - low vowels (ah, o)
                let lowEnergy = 0;         // 80-250 Hz - voiced consonants
                let totalEnergy = 0;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    const frequency = i * binSize;
                    const amplitude = frequencyData[i] / 255.0;
                    
                    totalEnergy += amplitude;
                    
                    if (frequency >= 4000 && frequency <= 8000) {
                        veryHighEnergy += amplitude;
                    } else if (frequency >= 2000 && frequency <= 4000) {
                        highEnergy += amplitude;
                    } else if (frequency >= 1000 && frequency <= 2000) {
                        midHighEnergy += amplitude;
                    } else if (frequency >= 500 && frequency <= 1000) {
                        midEnergy += amplitude;
                    } else if (frequency >= 250 && frequency <= 500) {
                        lowMidEnergy += amplitude;
                    } else if (frequency >= 80 && frequency <= 250) {
                        lowEnergy += amplitude;
                    }
                }
                
                // Normalize energies
                const numBins = frequencyData.length;
                veryHighEnergy /= numBins;
                highEnergy /= numBins;
                midHighEnergy /= numBins;
                midEnergy /= numBins;
                lowMidEnergy /= numBins;
                lowEnergy /= numBins;
                totalEnergy /= numBins;
                
                // Add temporal variation to encourage different phonemes
                const timeVariation = (Date.now() % 1000) / 1000; // 0-1 based on time
                const randomFactor = Math.random() * 0.1; // Small random factor
                
                // Debug logging (remove in production)
                if (Math.random() < 0.005) { // Log 0.5% of the time to avoid spam
                    console.log(`Energy - Total: ${totalEnergy.toFixed(3)}, VeryHigh: ${veryHighEnergy.toFixed(3)}, High: ${highEnergy.toFixed(3)}, MidHigh: ${midHighEnergy.toFixed(3)}, Mid: ${midEnergy.toFixed(3)}, LowMid: ${lowMidEnergy.toFixed(3)}, Low: ${lowEnergy.toFixed(3)}`);
                }
                
                // MUCH MORE AGGRESSIVE detection - Force variety
                if (totalEnergy < 0.03) { // Very low threshold for rest
                    return 'rest';
                }
                
                // Force different phonemes based on subtle energy differences
                if (totalEnergy > 0.03) {
                    
                    // Sibilants and fricatives - VERY SENSITIVE
                    if (veryHighEnergy > 0.05 + randomFactor) { // Very low threshold
                        const sibilantOptions = ['small_open', 'teeth_lower'];
                        return sibilantOptions[Math.floor((veryHighEnergy * 10 + timeVariation) % 2)];
                    }
                    
                    if (highEnergy > 0.04 + randomFactor) {
                        const fricativeOptions = ['teeth_lower', 'tongue_tip', 'small_open'];
                        return fricativeOptions[Math.floor((highEnergy * 15 + timeVariation) % 3)];
                    }
                    
                    // Vowels - MUCH MORE VARIETY
                    if (midHighEnergy > 0.06 + randomFactor) {
                        const highVowelOptions = ['tall_narrow', 'tall_open', 'medium_open'];
                        return highVowelOptions[Math.floor((midHighEnergy * 20 + timeVariation) % 3)];
                    }
                    
                    if (midEnergy > 0.08 + randomFactor) {
                        const midVowelOptions = ['medium_open', 'wide_open', 'round_medium'];
                        return midVowelOptions[Math.floor((midEnergy * 18 + timeVariation) % 3)];
                    }
                    
                    if (lowMidEnergy > 0.06 + randomFactor) {
                        const lowVowelOptions = ['wide_open', 'very_wide', 'round_medium', 'round_small'];
                        return lowVowelOptions[Math.floor((lowMidEnergy * 25 + timeVariation) % 4)];
                    }
                    
                    // Consonants - MORE VARIETY
                    if (lowEnergy > 0.05 + randomFactor) {
                        const consonantOptions = ['closed', 'medium_open', 'tongue_back', 'tongue_tip'];
                        return consonantOptions[Math.floor((lowEnergy * 30 + timeVariation) % 4)];
                    }
                    
                    // Diphthongs and transitions - FORCE MORE VARIETY
                    if (totalEnergy > 0.12) {
                        const diphthongOptions = ['diphthong_start', 'diphthong_end', 'round_medium', 'very_wide'];
                        return diphthongOptions[Math.floor((totalEnergy * 12 + timeVariation) % 4)];
                    }
                    
                    // Special sounds based on energy distribution
                    if (totalEnergy > 0.08) {
                        const specialOptions = ['aspirated', 'glottal', 'round_small', 'tongue_back'];
                        return specialOptions[Math.floor((totalEnergy * 8 + timeVariation * 2) % 4)];
                    }
                    
                    // Catch-all with rotation to ensure variety
                    const allPhonemes = [
                        'closed', 'small_open', 'teeth_lower', 'medium_open', 'wide_open', 'very_wide',
                        'round_small', 'round_medium', 'tall_narrow', 'tall_open', 'tongue_tip', 
                        'tongue_back', 'aspirated', 'glottal', 'diphthong_start', 'diphthong_end'
                    ];
                    
                    // Use energy + time to cycle through phonemes
                    const index = Math.floor((totalEnergy * 100 + timeVariation * 16) % allPhonemes.length);
                    return allPhonemes[index];
                }
                
                // Absolute fallback
                return 'medium_open';
            }
            
            updateMouthShape(phoneme) {
                if (expressionSystem && expressionSystem.phonemeMouths[phoneme]) {
                    const mouthShape = expressionSystem.phonemeMouths[phoneme];
                    
                    // Track detected phonemes
                    this.detectedPhonemes.add(phoneme);
                    
                    // Enhanced debug display with more info
                    const audioStatus = document.getElementById('audioStatus');
                    if (audioStatus && audioStatus.style.display !== 'none') {
                        const phonemeList = Array.from(this.detectedPhonemes).join(', ');
                        audioStatus.textContent = `üé§ Audio Lip Sync Active - Current: ${phoneme} | Detected: (${this.detectedPhonemes.size}/16) ${phonemeList}`;
                    }
                    
                    // Fast mouth animation - no complex timeline
                    gsap.to(expressionSystem.mouth, {
                        duration: 0.1, // Very fast for real-time feel
                        attr: {
                            cx: mouthShape.cx,
                            cy: mouthShape.cy,
                            rx: mouthShape.rx,
                            ry: mouthShape.ry
                        },
                        ease: "none" // No easing for maximum speed
                    });
                }
            }
            
            stopListening() {
                this.isListening = false;
                if (this.microphone) {
                    this.microphone.disconnect();
                }
                if (this.audioContext) {
                    this.audioContext.close();
                }
                console.log('Audio processing stopped');
            }
        }
        
        // Initialize the expression system
        document.addEventListener('DOMContentLoaded', function() {
            expressionSystem = new HighQualityExpressionSystem('avatarContainer', {
                enableSentimentAnalysis: true,
                animationDuration: 200,
                highQuality: true
            });
            
            // Initialize audio processor
            audioProcessor = new RealTimeAudioProcessor();
            
            setupEventListeners();
            
            // Set to idle state instead of cycling demo
            setTimeout(() => {
                expressionSystem.setExpression('idle');
            }, 500);
        });
        
        function setupEventListeners() {
            document.getElementById('sentimentToggle').addEventListener('change', function() {
                expressionSystem.options.enableSentimentAnalysis = this.checked;
            });
            
            document.getElementById('performanceToggle').addEventListener('change', function() {
                const metricsDiv = document.getElementById('performanceMetrics');
                if (this.checked) {
                    metricsDiv.style.display = 'block';
                    startPerformanceMonitoring();
                } else {
                    metricsDiv.style.display = 'none';
                    if (performanceInterval) {
                        clearInterval(performanceInterval);
                    }
                }
            });

            document.getElementById('qualityToggle').addEventListener('change', function() {
                expressionSystem.options.highQuality = this.checked;
                // Could implement dynamic quality switching here
            });
            
            // Real-time audio lip sync toggle
            document.getElementById('audioLipSyncToggle').addEventListener('change', async function() {
                const audioStatus = document.getElementById('audioStatus');
                
                if (this.checked) {
                    try {
                        await audioProcessor.startListening();
                        console.log('Real-time lip sync enabled');
                        // Set to speaking mode when audio is active
                        expressionSystem.setExpression('speaking');
                        // Show audio status
                        audioStatus.style.display = 'block';
                    } catch (error) {
                        console.error('Failed to start audio:', error);
                        this.checked = false;
                        alert('Microphone access denied or not available');
                        audioStatus.style.display = 'none';
                    }
                } else {
                    audioProcessor.stopListening();
                    console.log('Real-time lip sync disabled');
                    // Return to neutral when audio stops
                    expressionSystem.setExpression('neutral');
                    // Hide audio status
                    audioStatus.style.display = 'none';
                }
            });
            
            document.getElementById('textInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    analyzeText();
                }
            });
        }
        
        function setEmotion(emotion) {
            // Update active button
            document.querySelectorAll('.emotion-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Set expression
            expressionSystem.setExpression(emotion);
        }
        
        function analyzeText() {
            const text = document.getElementById('textInput').value.trim();
            if (text) {
                const result = expressionSystem.analyzeSentiment(text);
                console.log('Sentiment analysis:', result);
                
                // Trigger phoneme animation if speaking-related
                if (result && (result.emotion === 'speaking' || text.length > 20)) {
                    setTimeout(() => {
                        expressionSystem.animatePhonemes(text);
                    }, 300);
                }
                
                document.getElementById('textInput').value = '';
            }
        }

        function fetchServerSentiment() {
            const text = document.getElementById('textInput').value.trim();
            if (!text) return;

            fetch('/api/analyze_sentiment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ text: text })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server sentiment analysis:', data);
                if (data.emotion && data.confidence > 0.3) {
                    expressionSystem.setExpression(data.emotion);
                    
                    // Trigger phoneme animation if speaking-related
                    if (data.emotion === 'speaking' || text.length > 20) {
                        setTimeout(() => {
                            expressionSystem.animatePhonemes(text);
                        }, 300);
                    }
                }
                document.getElementById('textInput').value = '';
            })
            .catch(error => {
                console.error('Error:', error);
                // Fall back to client-side analysis
                analyzeText();
            });
        }
        
        function analyzePresetText(text) {
            document.getElementById('textInput').value = text;
            const result = expressionSystem.analyzeSentiment(text);
            console.log('Preset sentiment analysis:', result);
            
            setTimeout(() => {
                document.getElementById('textInput').value = '';
            }, 1000);
        }
        
        function startPerformanceMonitoring() {
            if (performanceInterval) clearInterval(performanceInterval);
            
            performanceInterval = setInterval(() => {
                const metrics = expressionSystem.getPerformanceMetrics();
                
                document.getElementById('fpsMetric').textContent = Math.round(metrics.fps);
                document.getElementById('emotionMetric').textContent = metrics.currentEmotion;
                document.getElementById('queueMetric').textContent = metrics.queueLength;
                document.getElementById('framesMetric').textContent = metrics.animationFrames;
                if (document.getElementById('qualityMetric')) {
                    document.getElementById('qualityMetric').textContent = metrics.quality;
                }
            }, 500);
        }

        function demoExpressions() {
            const emotions = ['happy', 'amazed', 'confused', 'determined', 'surprised', 'ecstatic', 'thinking', 'neutral'];
            let index = 0;
            
            const cycle = () => {
                expressionSystem.setExpression(emotions[index]);
                index = (index + 1) % emotions.length;
                
                setTimeout(cycle, 2500);
            };
            
            cycle();
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.altKey) {
                switch(e.key) {
                    case '1': setEmotion('neutral'); break;
                    case '2': setEmotion('happy'); break;
                    case '3': setEmotion('sad'); break;
                    case '4': setEmotion('surprised'); break;
                    case '5': setEmotion('thinking'); break;
                    case '6': setEmotion('speaking'); break;
                    case '7': setEmotion('confused'); break;
                    case '8': setEmotion('determined'); break;
                    case '9': setEmotion('concerned'); break;
                    case '0': setEmotion('amazed'); break;
                    case 'q': setEmotion('skeptical'); break;
                    case 'w': setEmotion('ecstatic'); break;
                }
            }
        });
    </script>
</body>
</html> 