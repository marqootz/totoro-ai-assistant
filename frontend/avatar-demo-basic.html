<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Expression System - Big Hero 6 Style Avatar (High Quality)</title>
    
    <!-- Core Libraries (no SocketIO) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flubber@0.4.2/build/flubber.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sentiment@5.0.2/build/sentiment.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .demo-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
        }

        .title {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 40px;
            font-size: 1.1em;
        }

        .avatar-container {
            display: flex;
            justify-content: center;
            margin-bottom: 40px;
            width: 100%; /* Full width container */
            max-width: 800px; /* Match demo container max-width */
        }

        #avatarContainer {
            width: 400px;
            height: 300px;
            min-width: 400px;  /* Prevent shrinking */
            max-width: 400px;  /* Prevent growing */
            min-height: 300px; /* Prevent shrinking */
            max-height: 300px; /* Prevent growing */
            border-radius: 20px;
            background: linear-gradient(145deg, #f0f0f0, #e6e6e6);
            border: 3px solid #e9ecef;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 2px 4px rgba(255,255,255,0.8),
                inset 0 -2px 4px rgba(0,0,0,0.1),
                0 8px 16px rgba(0,0,0,0.1);
            flex-shrink: 0; /* Prevent flexbox from shrinking this */
        }

        .avatar-face {
            width: 400px;    /* Fixed width */
            height: 300px;   /* Fixed height */
            max-width: 100%;
            max-height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .emotion-btn {
            background: #3498db;
            color: white;
        }

        .emotion-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .emotion-btn.active {
            background: #e74c3c;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .settings-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .settings-title {
            font-size: 1.2em;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .setting-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 25px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 25px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 19px;
            width: 19px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #3498db;
        }

        input:checked + .slider:before {
            transform: translateX(25px);
        }

        .text-input-section {
            margin-bottom: 20px;
        }

        .text-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 16px;
            margin-bottom: 10px;
            transition: border-color 0.3s ease;
        }

        .text-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .analyze-btn {
            background: #27ae60;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: background 0.3s ease;
        }

        .analyze-btn:hover {
            background: #229954;
        }

        .demo-text-samples {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .sample-btn {
            background: #f39c12;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .sample-btn:hover {
            background: #e67e22;
        }

        .performance-metrics {
            background: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #34495e;
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .status-indicator {
            text-align: center;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 8px;
            background: #27ae60;
            color: white;
            font-weight: 600;
        }

        .api-status {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }

        .quality-indicator {
            text-align: center;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 6px;
            background: #3498db;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <h1 class="title">üé≠ Big Hero 6 Expression System</h1>
        <p class="subtitle">High-Quality Fluid Avatar Expressions with Real-time Sentiment Analysis</p>
        
        <div class="status-indicator" id="statusIndicator">
            <div>‚úÖ System Running in High Quality Mode</div>
            <div class="api-status" id="apiStatus">Connecting to server...</div>
            <div class="api-status" id="audioStatus" style="display: none;">üé§ Real-time Audio Lip Sync Active</div>
        </div>
        
        <div class="quality-indicator">
            üé® High Resolution SVG ‚Ä¢ Smooth Morphing ‚Ä¢ Enhanced Gradients ‚Ä¢ 60fps Target
        </div>
        
        <div class="avatar-container">
            <div id="avatarContainer"></div>
        </div>
        
        <div class="controls">
            <button class="control-button emotion-btn" onclick="setEmotion('neutral')">üòê Neutral</button>
            <button class="control-button emotion-btn active" onclick="setEmotion('idle')">üòå Idle</button>
            <button class="control-button emotion-btn" onclick="setEmotion('happy')">üòä Happy</button>
            <button class="control-button emotion-btn" onclick="setEmotion('sad')">üò¢ Sad</button>
            <button class="control-button emotion-btn" onclick="setEmotion('surprised')">üò≤ Surprised</button>
            <button class="control-button emotion-btn" onclick="setEmotion('thinking')">ü§î Thinking</button>
            <button class="control-button emotion-btn" onclick="setEmotion('speaking')">üó£Ô∏è Speaking</button>
            <button class="control-button emotion-btn" onclick="setEmotion('confused')">üòï Confused</button>
            <button class="control-button emotion-btn" onclick="setEmotion('determined')">üò§ Determined</button>
            <button class="control-button emotion-btn" onclick="setEmotion('concerned')">üòü Concerned</button>
            <button class="control-button emotion-btn" onclick="setEmotion('amazed')">ü§© Amazed</button>
            <button class="control-button emotion-btn" onclick="setEmotion('skeptical')">ü§® Skeptical</button>
            <button class="control-button emotion-btn" onclick="setEmotion('ecstatic')">ü•≥ Ecstatic</button>
        </div>
        
        <div class="settings-section">
            <h3 class="settings-title">‚öôÔ∏è System Settings</h3>
            <div class="setting-item">
                <span>Real-time Sentiment Analysis</span>
                <label class="toggle">
                    <input type="checkbox" id="sentimentToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span>Performance Monitoring</span>
                <label class="toggle">
                    <input type="checkbox" id="performanceToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span>High Quality Rendering</span>
                <label class="toggle">
                    <input type="checkbox" id="qualityToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span>üé§ Real-time Audio Lip Sync</span>
                <label class="toggle">
                    <input type="checkbox" id="audioLipSyncToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        
        <div class="text-input-section">
            <input type="text" class="text-input" id="textInput" 
                   placeholder="Enter text to analyze sentiment and trigger expressions...">
            <button class="analyze-btn" onclick="analyzeText()">Analyze Sentiment</button>
            <button class="analyze-btn" onclick="fetchServerSentiment()">Send to Server</button>
            
            <div class="demo-text-samples">
                <button class="sample-btn" onclick="analyzePresetText('I am so excited about this new feature!')">üòä Happy Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('This is really disappointing and frustrating.')">üò¢ Sad Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('Wow, I never expected that to happen!')">üò≤ Surprised Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('Let me think about this carefully...')">ü§î Thinking Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('I am confused about what you mean.')">üòï Confused Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('I am determined to make this work!')">üò§ Determined Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('I am worried this might not work out.')">üòü Concerned Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('This is absolutely incredible and fantastic!')">ü§© Amazed Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('Hmm, I doubt that is really true.')">ü§® Skeptical Sample</button>
                <button class="sample-btn" onclick="analyzePresetText('This is the most amazing thing ever!')">ü•≥ Ecstatic Sample</button>
            </div>
        </div>
        
        <div class="performance-metrics" id="performanceMetrics" style="display: none;">
            <div class="metric-row">
                <span>FPS:</span>
                <span id="fpsMetric">--</span>
            </div>
            <div class="metric-row">
                <span>Current Emotion:</span>
                <span id="emotionMetric">neutral</span>
            </div>
            <div class="metric-row">
                <span>Queue Length:</span>
                <span id="queueMetric">0</span>
            </div>
            <div class="metric-row">
                <span>Animation Frames:</span>
                <span id="framesMetric">0</span>
            </div>
            <div class="metric-row">
                <span>Render Quality:</span>
                <span id="qualityMetric">High</span>
            </div>
        </div>
    </div>

    <script>
        // High Quality Expression System (Enhanced Version)
        class HighQualityExpressionSystem {
            constructor(containerId, options = {}) {
                this.container = document.getElementById(containerId);
                this.options = {
                    enableSentimentAnalysis: true,
                    animationDuration: 200,
                    highQuality: true,
                    ...options
                };
                
                this.currentEmotion = 'idle';
                this.isAnimating = false;
                
                this.init();
            }

            init() {
                this.createHighQualitySVGStructure();
                this.setupEnhancedExpressionPaths();
                this.initializeAnimationSystem();
                this.setupPerformanceMonitoring();
                this.checkServerStatus();
            }

            createHighQualitySVGStructure() {
                // Create high-resolution SVG based on original h1ro.svg design
                this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                this.svg.setAttribute('viewBox', '0 0 400 300'); // Adjusted for h1ro proportions
                this.svg.setAttribute('width', '400');
                this.svg.setAttribute('height', '300');
                this.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                this.svg.classList.add('avatar-face');
                this.svg.style.shapeRendering = 'geometricPrecision';
                this.svg.style.textRendering = 'optimizeLegibility';
                this.svg.style.overflow = 'visible';
                this.svg.style.display = 'block';
                
                // Create definitions for gradients and filters
                this.createSVGDefinitions();
                
                this.faceGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.faceGroup.classList.add('face-group');
                this.faceGroup.style.transformOrigin = '200px 150px'; // Center of 400x300 viewBox
                
                // Head with h1ro styling (oval shape)
                this.head = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.head.setAttribute('fill', '#D9D9D9');
                this.head.setAttribute('stroke', '#bbb');
                this.head.setAttribute('stroke-width', '1');
                this.head.setAttribute('filter', 'url(#headGlow)');
                this.head.style.transformOrigin = '200px 120px'; // Center of head shape
                
                // Eyes with h1ro styling (perfect circles)
                this.leftEye = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                this.leftEye.setAttribute('fill', '#000000');
                this.leftEye.setAttribute('filter', 'url(#eyeShadow)');
                this.leftEye.style.transformOrigin = '105px 120px'; // Center of left eye
                
                this.rightEye = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                this.rightEye.setAttribute('fill', '#000000');
                this.rightEye.setAttribute('filter', 'url(#eyeShadow)');
                this.rightEye.style.transformOrigin = '295px 120px'; // Center of right eye
                
                // Mouth (replaces bridge) - oval shape like original h1ro
                this.mouth = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                this.mouth.setAttribute('fill', '#000000');
                this.mouth.setAttribute('filter', 'url(#mouthGlow)');
                this.mouth.style.transformOrigin = '200px 180px'; // Center of mouth area
                
                // Assemble SVG
                this.faceGroup.appendChild(this.head);
                this.faceGroup.appendChild(this.leftEye);
                this.faceGroup.appendChild(this.rightEye);
                this.faceGroup.appendChild(this.mouth);
                this.svg.appendChild(this.faceGroup);
                this.container.appendChild(this.svg);
            }

            createSVGDefinitions() {
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                
                // Face gradient
                const faceGradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                faceGradient.setAttribute('id', 'faceGradient');
                faceGradient.setAttribute('cx', '50%');
                faceGradient.setAttribute('cy', '40%');
                faceGradient.setAttribute('r', '60%');
                
                const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop1.setAttribute('offset', '0%');
                stop1.setAttribute('stop-color', '#ffffff');
                stop1.setAttribute('stop-opacity', '0.9');
                
                const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop2.setAttribute('offset', '100%');
                stop2.setAttribute('stop-color', '#ecf0f1');
                stop2.setAttribute('stop-opacity', '1');
                
                faceGradient.appendChild(stop1);
                faceGradient.appendChild(stop2);
                
                // Drop shadow filter
                const dropShadow = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                dropShadow.setAttribute('id', 'dropShadow');
                dropShadow.setAttribute('x', '-50%');
                dropShadow.setAttribute('y', '-50%');
                dropShadow.setAttribute('width', '200%');
                dropShadow.setAttribute('height', '200%');
                
                const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'feDropShadow');
                shadow.setAttribute('dx', '0');
                shadow.setAttribute('dy', '2');
                shadow.setAttribute('stdDeviation', '2');
                shadow.setAttribute('flood-color', '#000000');
                shadow.setAttribute('flood-opacity', '0.2');
                
                dropShadow.appendChild(shadow);
                
                // Eye shadow filter
                const eyeShadow = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                eyeShadow.setAttribute('id', 'eyeShadow');
                
                const eyeShadowEffect = document.createElementNS('http://www.w3.org/2000/svg', 'feDropShadow');
                eyeShadowEffect.setAttribute('dx', '0');
                eyeShadowEffect.setAttribute('dy', '1');
                eyeShadowEffect.setAttribute('stdDeviation', '1');
                eyeShadowEffect.setAttribute('flood-color', '#000000');
                eyeShadowEffect.setAttribute('flood-opacity', '0.3');
                
                eyeShadow.appendChild(eyeShadowEffect);
                
                // Mouth glow filter
                const mouthGlow = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                mouthGlow.setAttribute('id', 'mouthGlow');
                
                const glow = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
                glow.setAttribute('stdDeviation', '1');
                glow.setAttribute('result', 'coloredBlur');
                
                const merge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
                const mergeNode1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                mergeNode1.setAttribute('in', 'coloredBlur');
                const mergeNode2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                mergeNode2.setAttribute('in', 'SourceGraphic');
                
                merge.appendChild(mergeNode1);
                merge.appendChild(mergeNode2);
                mouthGlow.appendChild(glow);
                mouthGlow.appendChild(merge);
                
                defs.appendChild(faceGradient);
                defs.appendChild(dropShadow);
                defs.appendChild(eyeShadow);
                defs.appendChild(mouthGlow);
                this.svg.appendChild(defs);
            }

            setupEnhancedExpressionPaths() {
                // H1RO-style avatar expressions with authentic mouth shapes and phonemes
                // Base expressions that will be varied generatively
                this.baseExpressions = {
                    neutral: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 120, r: 16 },
                        rightEye: { cx: 295, cy: 120, r: 16 },
                        mouth: { cx: 200, cy: 180, rx: 20, ry: 4 }, // Neutral closed mouth
                        headRotation: 0
                    },
                    idle: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 120, r: 16 },
                        rightEye: { cx: 295, cy: 120, r: 16 },
                        mouth: { cx: 200, cy: 180, rx: 18, ry: 3 }, // Slightly relaxed mouth
                        headRotation: 0
                    },
                    happy: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 115, r: 12 }, // Squinted with joy
                        rightEye: { cx: 295, cy: 115, r: 12 },
                        mouth: { cx: 200, cy: 185, rx: 25, ry: 12 }, // Smiling open mouth
                        headRotation: 5
                    },
                    sad: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 102, cy: 125, r: 18 }, // Droopy, larger
                        rightEye: { cx: 292, cy: 125, r: 18 },
                        mouth: { cx: 200, cy: 190, rx: 15, ry: 6 }, // Downturned mouth
                        headRotation: -8
                    },
                    surprised: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 118, r: 22 }, // Wide open
                        rightEye: { cx: 295, cy: 118, r: 22 },
                        mouth: { cx: 200, cy: 185, rx: 12, ry: 18 }, // Open "O" shape
                        headRotation: 2
                    },
                    thinking: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 122, r: 14 }, // Focused, smaller
                        rightEye: { cx: 295, cy: 122, r: 14 },
                        mouth: { cx: 200, cy: 182, rx: 8, ry: 3 }, // Small contemplative mouth
                        headRotation: -5
                    },
                    speaking: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 119, r: 15 }, // Engaged
                        rightEye: { cx: 295, cy: 119, r: 15 },
                        mouth: { cx: 200, cy: 184, rx: 18, ry: 10 }, // Active speaking mouth
                        headRotation: 3
                    },
                    confused: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 104, cy: 121, r: 15 }, // Asymmetrical confusion
                        rightEye: { cx: 296, cy: 119, r: 17 },
                        mouth: { cx: 200, cy: 183, rx: 6, ry: 8 }, // Small confused "o"
                        headRotation: -2
                    },
                    determined: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 118, r: 13 }, // Narrowed focus
                        rightEye: { cx: 295, cy: 118, r: 13 },
                        mouth: { cx: 200, cy: 182, rx: 22, ry: 3 }, // Tight determined line
                        headRotation: 4
                    },
                    concerned: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 103, cy: 123, r: 17 }, // Worried, closer together
                        rightEye: { cx: 293, cy: 123, r: 17 },
                        mouth: { cx: 200, cy: 188, rx: 14, ry: 8 }, // Worried frown
                        headRotation: -6
                    },
                    amazed: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 117, r: 24 }, // Very wide, wonder-filled
                        rightEye: { cx: 295, cy: 117, r: 24 },
                        mouth: { cx: 200, cy: 185, rx: 15, ry: 20 }, // Large amazed "O"
                        headRotation: 4
                    },
                    skeptical: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 103, cy: 119, r: 14 }, // Asymmetrical doubt
                        rightEye: { cx: 297, cy: 121, r: 16 },
                        mouth: { cx: 200, cy: 183, rx: 18, ry: 4 }, // Slight smirk
                        headRotation: -3
                    },
                    ecstatic: {
                        head: 'M400 120C400 180.751 310.457 230 200 230C89.5431 230 0 180.751 0 120C0 59.2487 50.4 10 200 10C350 10 400 59.2487 400 120Z',
                        leftEye: { cx: 105, cy: 112, r: 10 }, // Very squinted with extreme joy
                        rightEye: { cx: 295, cy: 112, r: 10 },
                        mouth: { cx: 200, cy: 188, rx: 30, ry: 15 }, // Wide ecstatic smile
                        headRotation: 8
                    }
                };
                
                // Enhanced phoneme mouth shapes for realistic speaking (OPTIMIZED FOR CARTOON ANIMATION)
                // Based on Disney 12-viseme standard + industry best practices
                // Now using professional SVG visemes from assets folder
                this.phonemeMouths = {
                    // 1. REST/NEUTRAL - Default position (keep ellipse for neutral)
                    rest: { type: 'ellipse', cx: 200, cy: 180, rx: 18, ry: 3 },
                    
                    // 2. CLOSED (Bilabials) - m, b, p (keep ellipse for closed lips)
                    closed: { type: 'ellipse', cx: 200, cy: 180, rx: 20, ry: 2 },
                    
                    // 3. OPEN (Ah sounds) - ah, aa, a
                    open: { type: 'svg', file: 'assets/ah.svg', scale: 0.8, offsetX: 0, offsetY: 10 },
                    
                    // 4. EE (High front vowels) - ee, i 
                    ee: { type: 'svg', file: 'assets/e.svg', scale: 0.7, offsetX: 0, offsetY: 5 },
                    
                    // 5. OH (Mid back vowels) - oh, o
                    oh: { type: 'svg', file: 'assets/oh.svg', scale: 0.8, offsetX: 0, offsetY: 8 },
                    
                    // 6. OO (Rounded vowels) - oo, u
                    oo: { type: 'svg', file: 'assets/w-oo.svg', scale: 0.7, offsetX: 0, offsetY: 5 },
                    
                    // 7. S (Sibilants) - s, z, sh, ch
                    s: { type: 'svg', file: 'assets/s.svg', scale: 0.8, offsetX: 0, offsetY: 0 },
                    
                    // 8. F/V (Labiodental) - f, v
                    fv: { type: 'svg', file: 'assets/f.svg', scale: 0.8, offsetX: 0, offsetY: 5 },
                    
                    // 9. TH (Dental) - th (both voiced/unvoiced) - use F variation
                    th: { type: 'svg', file: 'assets/f.svg', scale: 0.7, offsetX: 0, offsetY: 3 },
                    
                    // 10. L (Lateral) - l, r
                    l: { type: 'svg', file: 'assets/l.svg', scale: 0.8, offsetX: 0, offsetY: 5 },
                    
                    // 11. K/G (Velar) - k, g, ng - use UH for back consonants
                    k: { type: 'svg', file: 'assets/uh.svg', scale: 0.8, offsetX: 0, offsetY: 8 },
                    
                    // 12. T/D/N (Alveolar) - t, d, n
                    t: { type: 'svg', file: 'assets/d.svg', scale: 0.8, offsetX: 0, offsetY: 5 }
                };
                
                // Generate current expressions with variations
                this.generateExpressionVariations();
            }

            generateExpressionVariations() {
                this.expressions = {};
                
                Object.keys(this.baseExpressions).forEach(emotion => {
                    const base = this.baseExpressions[emotion];
                    
                    // Add small random variations while preserving emotion
                    const variation = {
                        head: base.head,
                        leftEye: {
                            cx: base.leftEye.cx + this.randomVariation(2), 
                            cy: base.leftEye.cy + this.randomVariation(1), 
                            r: Math.max(5, base.leftEye.r + this.randomVariation(1))
                        },
                        rightEye: {
                            cx: base.rightEye.cx + this.randomVariation(2), 
                            cy: base.rightEye.cy + this.randomVariation(1), 
                            r: Math.max(5, base.rightEye.r + this.randomVariation(1))
                        },
                        mouth: {
                            cx: base.mouth.cx + this.randomVariation(1), 
                            cy: base.mouth.cy + this.randomVariation(0.5), 
                            rx: Math.max(3, base.mouth.rx + this.randomVariation(0.5)), 
                            ry: Math.max(1, base.mouth.ry + this.randomVariation(0.5))
                        },
                        headRotation: base.headRotation + this.randomVariation(0.5)
                    };
                    
                    this.expressions[emotion] = variation;
                });
            }

            randomVariation(maxRange) {
                return (Math.random() - 0.5) * 2 * maxRange;
            }

            initializeAnimationSystem() {
                this.setInitialPaths();
                this.setupMorphingAnimations();
            }

            setInitialPaths() {
                const idle = this.expressions.idle;
                this.head.setAttribute('d', idle.head);
                this.leftEye.setAttribute('cx', idle.leftEye.cx);
                this.leftEye.setAttribute('cy', idle.leftEye.cy);
                this.leftEye.setAttribute('r', idle.leftEye.r);
                this.rightEye.setAttribute('cx', idle.rightEye.cx);
                this.rightEye.setAttribute('cy', idle.rightEye.cy);
                this.rightEye.setAttribute('r', idle.rightEye.r);
                this.mouth.setAttribute('cx', idle.mouth.cx);
                this.mouth.setAttribute('cy', idle.mouth.cy);
                this.mouth.setAttribute('rx', idle.mouth.rx);
                this.mouth.setAttribute('ry', idle.mouth.ry);
            }

            setupMorphingAnimations() {
                this.morphFunctions = {};
                
                Object.keys(this.expressions).forEach(emotion => {
                    this.morphFunctions[emotion] = {};
                    const paths = this.expressions[emotion];
                    
                    // Only setup morphing for head (path) - eyes and mouth use GSAP attribute animation
                    ['head'].forEach(element => {
                        this.morphFunctions[emotion][element] = {};
                        
                        Object.keys(this.expressions).forEach(targetEmotion => {
                            if (emotion !== targetEmotion) {
                                try {
                                    this.morphFunctions[emotion][element][targetEmotion] = 
                                        flubber.interpolate(paths[element], this.expressions[targetEmotion][element]);
                                } catch (e) {
                                    console.warn(`Failed to create morph from ${emotion} to ${targetEmotion} for ${element}`);
                                }
                            }
                        });
                    });
                });
            }

            setExpression(emotion, immediate = false) {
                if (immediate) {
                    this.setImmediateExpression(emotion);
                } else {
                    this.transitionToExpression(emotion);
                }
            }

            setImmediateExpression(emotion) {
                if (!this.expressions[emotion]) return;
                
                const paths = this.expressions[emotion];
                this.head.setAttribute('d', paths.head);
                this.leftEye.setAttribute('cx', paths.leftEye.cx);
                this.leftEye.setAttribute('cy', paths.leftEye.cy);
                this.leftEye.setAttribute('r', paths.leftEye.r);
                this.rightEye.setAttribute('cx', paths.rightEye.cx);
                this.rightEye.setAttribute('cy', paths.rightEye.cy);
                this.rightEye.setAttribute('r', paths.rightEye.r);
                this.mouth.setAttribute('cx', paths.mouth.cx);
                this.mouth.setAttribute('cy', paths.mouth.cy);
                this.mouth.setAttribute('rx', paths.mouth.rx);
                this.mouth.setAttribute('ry', paths.mouth.ry);
                
                this.currentEmotion = emotion;
            }

            transitionToExpression(emotion) {
                if (emotion === this.currentEmotion || this.isAnimating) return;
                
                this.isAnimating = true;
                const duration = this.options.animationDuration;
                
                // Regenerate expressions with slight variations each time
                this.generateExpressionVariations();
                
                const timeline = gsap.timeline({
                    onComplete: () => {
                        this.currentEmotion = emotion;
                        this.isAnimating = false;
                    }
                });
                
                // Get target expression
                const targetExpression = this.expressions[emotion];
                
                // Animate head rotation
                timeline.to(this.head, {
                    duration: duration / 1000 * 2,
                    rotation: targetExpression.headRotation,
                    ease: "cubic-bezier(0, 0, 0.58, 1)",
                    transformOrigin: "center center"
                }, 0);
                
                // Animate head morphing
                const headMorphFunction = this.morphFunctions[this.currentEmotion]?.head?.[emotion];
                if (headMorphFunction) {
                    timeline.to({}, {
                        duration: duration / 1000 * 2,
                        ease: "cubic-bezier(0, 0, 0.58, 1)",
                        onUpdate: function() {
                            const progress = this.progress();
                            const newPath = headMorphFunction(progress);
                            this.targets()[0].head.setAttribute('d', newPath);
                        }.bind({head: this.head})
                    }, 0);
                }
                
                // Animate left eye
                timeline.to(this.leftEye, {
                    duration: duration / 1000 * 2,
                    attr: {
                        cx: targetExpression.leftEye.cx,
                        cy: targetExpression.leftEye.cy,
                        r: targetExpression.leftEye.r
                    },
                    ease: "cubic-bezier(0, 0, 0.58, 1)"
                }, 0);
                
                // Animate right eye
                timeline.to(this.rightEye, {
                    duration: duration / 1000 * 2,
                    attr: {
                        cx: targetExpression.rightEye.cx,
                        cy: targetExpression.rightEye.cy,
                        r: targetExpression.rightEye.r
                    },
                    ease: "cubic-bezier(0, 0, 0.58, 1)"
                }, 0);
                
                // Animate mouth
                timeline.to(this.mouth, {
                    duration: duration / 1000 * 2,
                    attr: {
                        cx: targetExpression.mouth.cx,
                        cy: targetExpression.mouth.cy,
                        rx: targetExpression.mouth.rx,
                        ry: targetExpression.mouth.ry
                    },
                    ease: "cubic-bezier(0, 0, 0.58, 1)"
                }, 0);
                
                // Add subtle scaling animation for eyes and mouth
                [this.leftEye, this.rightEye, this.mouth].forEach((element, index) => {
                    timeline.to(element, {
                        duration: duration / 1000,
                        scale: 1.05,
                        ease: "cubic-bezier(0, 0, 0.58, 1)",
                        transformOrigin: "center center"
                    }, index * 0.005);
                    
                    timeline.to(element, {
                        duration: duration / 1000,
                        scale: 1.0,
                        ease: "cubic-bezier(0, 0, 0.58, 1)",
                        transformOrigin: "center center"
                    }, duration / 1000 + index * 0.005);
                });
            }

            analyzeSentiment(text) {
                if (typeof Sentiment !== 'undefined') {
                    const sentiment = new Sentiment();
                    const result = sentiment.analyze(text);
                    const emotion = this.determineEmotion(result);
                    const confidence = Math.abs(result.score) / Math.max(text.split(' ').length, 1);
                    
                    if (confidence > 0.3) {
                        this.setExpression(emotion);
                    }
                    
                    return { emotion, confidence, result };
                }
                return null;
            }

            determineEmotion(sentimentResult) {
                const score = sentimentResult.score;
                const comparative = sentimentResult.comparative;
                const tokens = sentimentResult.tokens.map(t => t.toLowerCase());
                
                // Check for specific emotional keywords first
                if (tokens.some(token => ['amazing', 'incredible', 'fantastic', 'awesome'].includes(token))) {
                    return Math.random() > 0.5 ? 'amazed' : 'ecstatic';
                }
                
                if (tokens.some(token => ['confused', 'puzzled', 'unclear', 'what', 'huh'].includes(token))) {
                    return 'confused';
                }
                
                if (tokens.some(token => ['determined', 'focused', 'will', 'must', 'definitely'].includes(token))) {
                    return 'determined';
                }
                
                if (tokens.some(token => ['worried', 'concerned', 'anxious', 'nervous'].includes(token))) {
                    return 'concerned';
                }
                
                if (tokens.some(token => ['skeptical', 'doubt', 'really', 'sure', 'hmm'].includes(token))) {
                    return 'skeptical';
                }
                
                // Enhanced sentiment-based emotion detection
                if (score > 5) return 'ecstatic';
                if (score > 3) return 'happy';
                if (score > 1) return Math.random() > 0.5 ? 'happy' : 'amazed';
                
                if (score < -5) return Math.random() > 0.5 ? 'sad' : 'concerned';
                if (score < -3) return 'sad';
                if (score < -1) return Math.random() > 0.5 ? 'sad' : 'concerned';
                
                if (Math.abs(comparative) > 0.5) return 'surprised';
                if (Math.abs(comparative) > 0.3) return Math.random() > 0.5 ? 'surprised' : 'amazed';
                
                if (tokens.some(token => 
                    ['think', 'consider', 'maybe', 'perhaps', 'wondering', 'hmm'].includes(token)
                )) {
                    return Math.random() > 0.5 ? 'thinking' : 'confused';
                }
                
                return 'neutral';
            }

            setupPerformanceMonitoring() {
                this.performanceMetrics = {
                    animationFrames: 0,
                    lastFrameTime: performance.now(),
                    avgFrameTime: 16.67
                };
                
                this.startPerformanceMonitoring();
            }

            startPerformanceMonitoring() {
                const monitor = () => {
                    const currentTime = performance.now();
                    const frameTime = currentTime - this.performanceMetrics.lastFrameTime;
                    
                    this.performanceMetrics.avgFrameTime = 
                        (this.performanceMetrics.avgFrameTime * 0.9) + (frameTime * 0.1);
                    
                    this.performanceMetrics.lastFrameTime = currentTime;
                    this.performanceMetrics.animationFrames++;
                    
                    requestAnimationFrame(monitor);
                };
                
                requestAnimationFrame(monitor);
            }

            checkServerStatus() {
                fetch('/api/status')
                    .then(response => response.json())
                    .then(data => {
                        const statusEl = document.getElementById('apiStatus');
                        statusEl.textContent = `‚úÖ Connected to ${data.server_type || 'server'} - Mode: ${data.demo_mode ? 'Demo' : 'Production'}`;
                    })
                    .catch(error => {
                        const statusEl = document.getElementById('apiStatus');
                        statusEl.textContent = '‚ö†Ô∏è Server connection failed';
                    });
            }

            getPerformanceMetrics() {
                return {
                    ...this.performanceMetrics,
                    fps: 1000 / this.performanceMetrics.avgFrameTime,
                    currentEmotion: this.currentEmotion,
                    queueLength: 0,
                    quality: this.options.highQuality ? 'High' : 'Standard'
                };
            }

            // Add phoneme animation for realistic speaking
            animatePhonemes(text) {
                if (!text) return;
                
                // Simple phoneme mapping based on text
                const phonemes = this.textToPhonemes(text);
                const timeline = gsap.timeline();
                
                phonemes.forEach((phoneme, index) => {
                    const mouthShape = this.phonemeMouths[phoneme] || this.phonemeMouths.medium_open;
                    
                    timeline.to(this.mouth, {
                        duration: 0.15,
                        attr: {
                            cx: mouthShape.cx,
                            cy: mouthShape.cy,
                            rx: mouthShape.rx,
                            ry: mouthShape.ry
                        },
                        ease: "power2.out"
                    }, index * 0.1);
                });
                
                // Return to speaking mouth shape
                timeline.to(this.mouth, {
                    duration: 0.2,
                    attr: {
                        cx: this.expressions.speaking.mouth.cx,
                        cy: this.expressions.speaking.mouth.cy,
                        rx: this.expressions.speaking.mouth.rx,
                        ry: this.expressions.speaking.mouth.ry
                    },
                    ease: "power2.out"
                });
            }
            
            textToPhonemes(text) {
                // Enhanced phoneme mapping with co-articulation consideration
                const phonemeMap = {
                    // Bilabials
                    'b': 'closed', 'm': 'closed', 'p': 'closed',
                    
                    // Fricatives and Sibilants  
                    's': 'small_open', 'z': 'small_open', 'sh': 'small_open', 
                    'ch': 'small_open', 'j': 'small_open',
                    'f': 'teeth_lower', 'v': 'teeth_lower',
                    
                    // Alveolars
                    'd': 'medium_open', 't': 'medium_open', 'n': 'medium_open',
                    
                    // Liquids
                    'l': 'tongue_tip', 'r': 'tongue_tip',
                    
                    // Fricatives
                    'th': 'tongue_tip', // both voiced and unvoiced
                    
                    // Velars
                    'k': 'tongue_back', 'g': 'tongue_back', 'ng': 'tongue_back',
                    
                    // Glottals and Aspirated
                    'h': 'aspirated', 'wh': 'aspirated',
                    
                    // Vowels - High
                    'i': 'tall_narrow', 'ee': 'tall_narrow', 
                    'ih': 'tall_open', 'eh': 'tall_open',
                    
                    // Vowels - Mid
                    'e': 'medium_open', 'uh': 'medium_open',
                    'er': 'medium_open', 'ur': 'medium_open',
                    
                    // Vowels - Low  
                    'a': 'wide_open', 'ah': 'wide_open', 'o': 'wide_open',
                    'aa': 'very_wide', 'aw': 'very_wide',
                    
                    // Rounded vowels
                    'u': 'round_small', 'oo': 'round_medium', 
                    'w': 'round_medium',
                    
                    // Diphthongs
                    'ay': 'diphthong_start', 'oy': 'diphthong_start', 
                    'ow': 'diphthong_start', 'ey': 'diphthong_start'
                };
                
                // Simple word-to-phoneme mapping for common words
                const wordPhonemes = {
                    'the': ['th', 'uh'],
                    'and': ['ah', 'n', 'd'],
                    'hello': ['h', 'eh', 'l', 'ow'],
                    'world': ['w', 'er', 'l', 'd'],
                    'how': ['h', 'ow'],
                    'are': ['ah', 'r'],
                    'you': ['y', 'oo'],
                    'what': ['wh', 'ah', 't'],
                    'when': ['wh', 'eh', 'n'],
                    'where': ['wh', 'eh', 'r'],
                    'this': ['th', 'ih', 's'],
                    'that': ['th', 'ah', 't'],
                    'with': ['w', 'ih', 'th'],
                    'will': ['w', 'ih', 'l'],
                    'can': ['k', 'ah', 'n'],
                    'could': ['k', 'oo', 'd'],
                    'should': ['sh', 'oo', 'd'],
                    'would': ['w', 'oo', 'd']
                };
                
                const phonemes = [];
                const words = text.toLowerCase().split(/\s+/);
                
                for (let word of words) {
                    // Clean word of punctuation
                    const cleanWord = word.replace(/[^\w]/g, '');
                    
                    if (wordPhonemes[cleanWord]) {
                        // Use pre-mapped phonemes for known words
                        phonemes.push(...wordPhonemes[cleanWord]);
                    } else {
                        // Fall back to character-based mapping
                        for (let char of cleanWord) {
                            phonemes.push(phonemeMap[char] || 'medium_open');
                        }
                    }
                    
                    // Add brief pause between words
                    if (words.indexOf(word) < words.length - 1) {
                        phonemes.push('rest');
                    }
                }
                
                return phonemes;
            }
            
            updateMouthShapeWithTiming(phoneme) {
                if (expressionSystem && expressionSystem.phonemeMouths[phoneme]) {
                    const mouthShape = expressionSystem.phonemeMouths[phoneme];
                    
                    // Track detected phonemes
                    this.detectedPhonemes.add(phoneme);
                    
                    // Calculate core shape usage percentage
                    const corePercentage = Math.round((this.coreShapeUsage / this.totalShapeUsage) * 100);
                    
                    // Enhanced debug display with professional metrics
                    const audioStatus = document.getElementById('audioStatus');
                    if (audioStatus && audioStatus.style.display !== 'none') {
                        const phonemeList = Array.from(this.detectedPhonemes).join(', ');
                        audioStatus.textContent = `üé§ Professional SVG Lip Sync - Current: ${phoneme} | Core Usage: ${corePercentage}% | Detected: (${this.detectedPhonemes.size}/12) ${phonemeList}`;
                    }
                    
                    // Determine animation duration based on phoneme type
                    let duration = 0.1; // Default fast animation
                    
                    // Professional hold timing for plosives (b, p, t, d, k, g)
                    if (['closed', 't', 'k'].includes(phoneme)) {
                        duration = 0.15; // Hold plosives longer (3 frames at 20fps)
                    }
                    
                    // Stylized exaggeration for cartoon appeal
                    let scaleMultiplier = 1.0;
                    if (['open', 'ee', 'oh'].includes(phoneme)) {
                        scaleMultiplier = 1.1; // 10% larger for expressive vowels
                    }
                    
                    // Handle different mouth shape types
                    if (mouthShape.type === 'svg') {
                        // Try to load SVG immediately, fallback to ellipse if not ready
                        const svgReady = this.loadSVGMouthSync(mouthShape, scaleMultiplier, duration);
                        if (!svgReady) {
                            // Immediate fallback for real-time performance
                            this.showEllipseMouth();
                            gsap.to(expressionSystem.mouth, {
                                duration: duration,
                                attr: { cx: 200, cy: 180, rx: 15 * scaleMultiplier, ry: 8 * scaleMultiplier },
                                ease: "power2.out"
                            });
                        }
                    } else {
                        // Use ellipse for rest/closed positions - hide SVG mouth first
                        this.showEllipseMouth();
                        gsap.to(expressionSystem.mouth, {
                            duration: duration,
                            attr: {
                                cx: mouthShape.cx,
                                cy: mouthShape.cy,
                                rx: mouthShape.rx * scaleMultiplier,
                                ry: mouthShape.ry * scaleMultiplier
                            },
                            ease: "power2.out"
                        });
                    }
                    
                    // Secondary facial animations (Emotional Contextualization)
                    this.addSecondaryAnimations(phoneme);
                }
            }
            
            loadSVGMouthSync(mouthShape, scaleMultiplier, duration) {
                // Synchronous loading from cache for real-time performance
                const svgText = this.svgCache.get(mouthShape.file);
                if (!svgText) {
                    console.log(`SVG not cached yet: ${mouthShape.file}`);
                    return false; // Not ready, use fallback
                }
                
                try {
                    // Parse SVG
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                    const svgElement = svgDoc.documentElement;
                    
                    // Calculate position and scale
                    const baseX = 200 + mouthShape.offsetX;
                    const baseY = 180 + mouthShape.offsetY;
                    const scale = mouthShape.scale * scaleMultiplier;
                    
                    // Remove old mouth (if exists)
                    const oldMouth = expressionSystem.svg.querySelector('#current-mouth');
                    if (oldMouth) {
                        oldMouth.remove();
                    }
                    
                    // Create new mouth group
                    const mouthGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    mouthGroup.setAttribute('id', 'current-mouth');
                    mouthGroup.setAttribute('transform', `translate(${baseX - 39.5}, ${baseY - 15}) scale(${scale})`);
                    
                    // Copy SVG content
                    const svgContent = svgElement.querySelector('g');
                    if (svgContent) {
                        mouthGroup.appendChild(svgContent.cloneNode(true));
                        
                        // Hide ellipse mouth and show SVG
                        expressionSystem.mouth.style.display = 'none';
                        expressionSystem.svg.appendChild(mouthGroup);
                        
                        // Quick entrance animation for real-time feel
                        gsap.from(mouthGroup, {
                            duration: 0.05, // Very fast
                            scale: 0.95,
                            opacity: 0.7,
                            ease: "power1.out"
                        });
                        
                        return true; // Success
                    }
                } catch (error) {
                    console.warn('Error displaying cached SVG:', error);
                }
                
                return false; // Failed
            }
            
            async loadSVGMouth(mouthShape, scaleMultiplier, duration) {
                try {
                    // Get SVG content from cache or fetch it
                    let svgText = this.svgCache.get(mouthShape.file);
                    if (!svgText) {
                        console.log(`Loading SVG from network: ${mouthShape.file}`);
                        const response = await fetch(mouthShape.file);
                        svgText = await response.text();
                        this.svgCache.set(mouthShape.file, svgText); // Cache for next time
                    }
                    
                    // Parse SVG
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                    const svgElement = svgDoc.documentElement;
                    
                    // Calculate position and scale
                    const baseX = 200 + mouthShape.offsetX;
                    const baseY = 180 + mouthShape.offsetY;
                    const scale = mouthShape.scale * scaleMultiplier;
                    
                    // Remove old mouth (if exists)
                    const oldMouth = expressionSystem.svg.querySelector('#current-mouth');
                    if (oldMouth) {
                        oldMouth.remove();
                    }
                    
                    // Create new mouth group
                    const mouthGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    mouthGroup.setAttribute('id', 'current-mouth');
                    mouthGroup.setAttribute('transform', `translate(${baseX - 39.5}, ${baseY - 15}) scale(${scale})`);
                    
                    // Copy SVG content
                    const svgContent = svgElement.querySelector('g');
                    if (svgContent) {
                        mouthGroup.appendChild(svgContent.cloneNode(true));
                        
                        // Hide ellipse mouth and show SVG
                        expressionSystem.mouth.style.display = 'none';
                        expressionSystem.svg.appendChild(mouthGroup);
                        
                        // Animate entrance (faster for real-time)
                        gsap.from(mouthGroup, {
                            duration: duration * 0.5, // Half duration for snappy feel
                            scale: 0.9,
                            opacity: 0,
                            ease: "power2.out"
                        });
                    }
                } catch (error) {
                    console.warn('Failed to load SVG mouth:', mouthShape.file, error);
                    // Fallback to ellipse
                    this.showEllipseMouth();
                    gsap.to(expressionSystem.mouth, {
                        duration: duration,
                        attr: { rx: 15, ry: 8 },
                        ease: "power2.out"
                    });
                }
            }
            
            showEllipseMouth() {
                // Hide any SVG mouth
                const oldMouth = expressionSystem.svg.querySelector('#current-mouth');
                if (oldMouth) {
                    gsap.to(oldMouth, {
                        duration: 0.1,
                        opacity: 0,
                        onComplete: () => oldMouth.remove()
                    });
                }
                
                // Show ellipse mouth
                expressionSystem.mouth.style.display = 'block';
            }
            
            addSecondaryAnimations(phoneme) {
                if (!expressionSystem) return;
                
                // Cheek/nose movement for nasals (m, n, ng)
                if (phoneme === 'closed' || phoneme === 't') {
                    // Subtle nostril flare for nasal consonants
                    gsap.to(expressionSystem.leftEye, {
                        duration: 0.1,
                        attr: { cy: expressionSystem.leftEye.getAttribute('cy') - 1 },
                        ease: "power2.out",
                        yoyo: true,
                        repeat: 1
                    });
                    gsap.to(expressionSystem.rightEye, {
                        duration: 0.1,
                        attr: { cy: expressionSystem.rightEye.getAttribute('cy') - 1 },
                        ease: "power2.out",
                        yoyo: true,
                        repeat: 1
                    });
                }
                
                // Eye dilation for stressed vowels (emotional intensity)
                if (['open', 'ee', 'oh'].includes(phoneme)) {
                    const currentRadius = parseInt(expressionSystem.leftEye.getAttribute('r'));
                    gsap.to([expressionSystem.leftEye, expressionSystem.rightEye], {
                        duration: 0.08,
                        attr: { r: currentRadius + 1 },
                        ease: "power2.out",
                        yoyo: true,
                        repeat: 1
                    });
                }
                
                // Subtle head movement for emphasis (20/80 rule - body mechanics)
                if (['s', 'fv', 'th'].includes(phoneme)) {
                    gsap.to(expressionSystem.faceGroup, {
                        duration: 0.15,
                        rotation: Math.random() > 0.5 ? 0.5 : -0.5,
                        ease: "power2.out",
                        yoyo: true,
                        repeat: 1
                    });
                }
            }
        }

        // Global variables
        let expressionSystem;
        let performanceInterval;
        let audioProcessor; // New audio processing system
        
        // Audio processing class for real-time lip sync (PROFESSIONAL TECHNIQUES)
        class RealTimeAudioProcessor {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.isListening = false;
                this.dataArray = null;
                this.bufferLength = 0;
                this.lastPhoneme = 'rest';
                this.phonemeHistory = []; // For anticipatory timing
                this.detectedPhonemes = new Set();
                this.frameCounter = 0;
                
                // Professional timing settings
                this.anticipationFrames = 2; // Place shapes 1-2 frames early
                this.holdFrames = 3; // Hold plosives for 3 frames
                
                // Core 5 shapes for 60-70% coverage (Limited Articulation Principle)
                this.coreShapes = ['rest', 'open', 'closed', 'ee', 'oh'];
                this.coreShapeUsage = 0;
                this.totalShapeUsage = 0;
                
                // SVG cache for faster loading
                this.svgCache = new Map();
                this.preloadSVGs();
            }
            
            async preloadSVGs() {
                // Preload all SVG visemes for faster real-time performance
                const svgFiles = [
                    'assets/ah.svg', 'assets/e.svg', 'assets/oh.svg', 'assets/w-oo.svg',
                    'assets/s.svg', 'assets/f.svg', 'assets/l.svg', 'assets/d.svg', 'assets/uh.svg'
                ];
                
                for (const file of svgFiles) {
                    try {
                        const response = await fetch(file);
                        const svgText = await response.text();
                        this.svgCache.set(file, svgText);
                        console.log(`Preloaded: ${file}`);
                    } catch (error) {
                        console.warn(`Failed to preload: ${file}`, error);
                    }
                }
                console.log(`SVG cache ready: ${this.svgCache.size} files loaded`);
            }
            
            async startListening() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { 
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 16000 // Lower sample rate for performance
                        } 
                    });
                    
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.analyser = this.audioContext.createAnalyser();
                    
                    // Optimize for performance
                    this.analyser.fftSize = 512; // Smaller FFT for speed
                    this.analyser.smoothingTimeConstant = 0.8; // Professional smoothing
                    
                    this.bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(this.bufferLength);
                    
                    this.microphone.connect(this.analyser);
                    this.isListening = true;
                    
                    this.processAudio();
                    console.log('Real-time audio processing started');
                    
                } catch (error) {
                    console.error('Error starting audio:', error);
                }
            }
            
            processAudio() {
                if (!this.isListening) return;
                
                this.analyser.getByteFrequencyData(this.dataArray);
                this.frameCounter++;
                
                // Professional phoneme detection with anticipatory timing
                const detectedPhoneme = this.detectPhoneme(this.dataArray);
                
                // Add to history for anticipatory timing (1-2 frames early)
                this.phonemeHistory.push({
                    phoneme: detectedPhoneme,
                    frame: this.frameCounter,
                    timestamp: Date.now()
                });
                
                // Keep only recent history (last 10 frames)
                if (this.phonemeHistory.length > 10) {
                    this.phonemeHistory.shift();
                }
                
                // Apply anticipatory timing - use phoneme from 2 frames ago
                let phonemeToApply = detectedPhoneme;
                if (this.phonemeHistory.length >= this.anticipationFrames) {
                    const anticipatedIndex = this.phonemeHistory.length - this.anticipationFrames;
                    phonemeToApply = this.phonemeHistory[anticipatedIndex].phoneme;
                }
                
                // Professional core shape prioritization (60-70% rule)
                this.totalShapeUsage++;
                if (this.coreShapes.includes(phonemeToApply)) {
                    this.coreShapeUsage++;
                }
                
                // Only update if phoneme changed (reduces jitter)
                if (phonemeToApply !== this.lastPhoneme) {
                    this.updateMouthShapeWithTiming(phonemeToApply);
                    this.lastPhoneme = phonemeToApply;
                }
                
                // High frequency processing for real-time feel
                requestAnimationFrame(() => this.processAudio());
            }
            
            detectPhoneme(frequencyData) {
                // CARTOON-OPTIMIZED PHONEME DETECTION (Disney 12-Viseme Standard)
                // Simplified for stylized animation rather than hyper-realistic lip sync
                const sampleRate = this.audioContext.sampleRate;
                const binSize = sampleRate / this.analyser.fftSize;
                
                // Simplified frequency analysis for cartoon aesthetics
                let highEnergy = 0;        // 2000+ Hz - fricatives and sibilants
                let midEnergy = 0;         // 500-2000 Hz - vowels
                let lowEnergy = 0;         // 80-500 Hz - voiced consonants
                let totalEnergy = 0;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    const frequency = i * binSize;
                    const amplitude = frequencyData[i] / 255.0;
                    
                    totalEnergy += amplitude;
                    
                    if (frequency >= 2000) {
                        highEnergy += amplitude;
                    } else if (frequency >= 500) {
                        midEnergy += amplitude;
                    } else if (frequency >= 80) {
                        lowEnergy += amplitude;
                    }
                }
                
                // Normalize energies
                const numBins = frequencyData.length;
                highEnergy /= numBins;
                midEnergy /= numBins;
                lowEnergy /= numBins;
                totalEnergy /= numBins;
                
                // Cartoon-style detection (clear, stylized choices)
                if (totalEnergy < 0.04) {
                    return 'rest';
                }
                
                // High frequency = sibilants and fricatives
                if (highEnergy > 0.15) {
                    if (highEnergy > 0.25) {
                        return 's'; // Strong sibilants (s, z, sh, ch)
                    } else {
                        return Math.random() > 0.5 ? 'fv' : 'th'; // f/v or th sounds
                    }
                }
                
                // Mid frequency = vowels (most important for cartoon expression)
                if (midEnergy > 0.2) {
                    const vowelType = (midEnergy * 10 + Date.now() / 1000) % 4;
                    
                    if (vowelType < 1) {
                        return 'ee'; // High front vowels
                    } else if (vowelType < 2) {
                        return 'open'; // Open vowels (ah, a)
                    } else if (vowelType < 3) {
                        return 'oh'; // Mid back vowels
                    } else {
                        return 'oo'; // Rounded vowels
                    }
                }
                
                // Low frequency = consonants
                if (lowEnergy > 0.15) {
                    const consonantType = (lowEnergy * 15 + Date.now() / 2000) % 4;
                    
                    if (consonantType < 1) {
                        return 'closed'; // Bilabials (m, b, p)
                    } else if (consonantType < 2) {
                        return 't'; // Alveolars (t, d, n)
                    } else if (consonantType < 3) {
                        return 'k'; // Velars (k, g, ng)
                    } else {
                        return 'l'; // Laterals (l, r)
                    }
                }
                
                // Moderate energy = general speech
                if (totalEnergy > 0.08) {
                    // Cycle through most expressive visemes for cartoon appeal
                    const expressiveVisemes = ['open', 'ee', 'oh', 'oo', 's', 't'];
                    const index = Math.floor((totalEnergy * 20 + Date.now() / 1000) % expressiveVisemes.length);
                    return expressiveVisemes[index];
                }
                
                // Default to natural speaking position
                return 'open';
            }
            
            updateMouthShape(phoneme) {
                if (expressionSystem && expressionSystem.phonemeMouths[phoneme]) {
                    const mouthShape = expressionSystem.phonemeMouths[phoneme];
                    
                    // Track detected phonemes
                    this.detectedPhonemes.add(phoneme);
                    
                    // Enhanced debug display with more info
                    const audioStatus = document.getElementById('audioStatus');
                    if (audioStatus && audioStatus.style.display !== 'none') {
                        const phonemeList = Array.from(this.detectedPhonemes).join(', ');
                        audioStatus.textContent = `üé§ Audio Lip Sync Active - Current: ${phoneme} | Detected: (${this.detectedPhonemes.size}/12) ${phonemeList}`;
                    }
                    
                    // Fast mouth animation - no complex timeline
                    gsap.to(expressionSystem.mouth, {
                        duration: 0.1, // Very fast for real-time feel
                        attr: {
                            cx: mouthShape.cx,
                            cy: mouthShape.cy,
                            rx: mouthShape.rx,
                            ry: mouthShape.ry
                        },
                        ease: "none" // No easing for maximum speed
                    });
                }
            }
            
            stopListening() {
                this.isListening = false;
                if (this.microphone) {
                    this.microphone.disconnect();
                }
                if (this.audioContext) {
                    this.audioContext.close();
                }
                console.log('Audio processing stopped');
            }
        }
        
        // Initialize the expression system
        document.addEventListener('DOMContentLoaded', function() {
            expressionSystem = new HighQualityExpressionSystem('avatarContainer', {
                enableSentimentAnalysis: true,
                animationDuration: 200,
                highQuality: true
            });
            
            // Initialize audio processor
            audioProcessor = new RealTimeAudioProcessor();
            
            setupEventListeners();
            
            // Set to idle state instead of cycling demo
            setTimeout(() => {
                expressionSystem.setExpression('idle');
            }, 500);
        });
        
        function setupEventListeners() {
            document.getElementById('sentimentToggle').addEventListener('change', function() {
                expressionSystem.options.enableSentimentAnalysis = this.checked;
            });
            
            document.getElementById('performanceToggle').addEventListener('change', function() {
                const metricsDiv = document.getElementById('performanceMetrics');
                if (this.checked) {
                    metricsDiv.style.display = 'block';
                    startPerformanceMonitoring();
                } else {
                    metricsDiv.style.display = 'none';
                    if (performanceInterval) {
                        clearInterval(performanceInterval);
                    }
                }
            });

            document.getElementById('qualityToggle').addEventListener('change', function() {
                expressionSystem.options.highQuality = this.checked;
                // Could implement dynamic quality switching here
            });
            
            // Real-time audio lip sync toggle
            document.getElementById('audioLipSyncToggle').addEventListener('change', async function() {
                const audioStatus = document.getElementById('audioStatus');
                
                if (this.checked) {
                    try {
                        await audioProcessor.startListening();
                        console.log('Real-time lip sync enabled');
                        // Set to speaking mode when audio is active
                        expressionSystem.setExpression('speaking');
                        // Show audio status
                        audioStatus.style.display = 'block';
                    } catch (error) {
                        console.error('Failed to start audio:', error);
                        this.checked = false;
                        alert('Microphone access denied or not available');
                        audioStatus.style.display = 'none';
                    }
                } else {
                    audioProcessor.stopListening();
                    console.log('Real-time lip sync disabled');
                    // Return to neutral when audio stops
                    expressionSystem.setExpression('neutral');
                    // Hide audio status
                    audioStatus.style.display = 'none';
                }
            });
            
            document.getElementById('textInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    analyzeText();
                }
            });
        }
        
        function setEmotion(emotion) {
            // Update active button
            document.querySelectorAll('.emotion-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Set expression
            expressionSystem.setExpression(emotion);
        }
        
        function analyzeText() {
            const text = document.getElementById('textInput').value.trim();
            if (text) {
                const result = expressionSystem.analyzeSentiment(text);
                console.log('Sentiment analysis:', result);
                
                // Trigger phoneme animation if speaking-related
                if (result && (result.emotion === 'speaking' || text.length > 20)) {
                    setTimeout(() => {
                        expressionSystem.animatePhonemes(text);
                    }, 300);
                }
                
                document.getElementById('textInput').value = '';
            }
        }

        function fetchServerSentiment() {
            const text = document.getElementById('textInput').value.trim();
            if (!text) return;

            fetch('/api/analyze_sentiment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ text: text })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server sentiment analysis:', data);
                if (data.emotion && data.confidence > 0.3) {
                    expressionSystem.setExpression(data.emotion);
                    
                    // Trigger phoneme animation if speaking-related
                    if (data.emotion === 'speaking' || text.length > 20) {
                        setTimeout(() => {
                            expressionSystem.animatePhonemes(text);
                        }, 300);
                    }
                }
                document.getElementById('textInput').value = '';
            })
            .catch(error => {
                console.error('Error:', error);
                // Fall back to client-side analysis
                analyzeText();
            });
        }
        
        function analyzePresetText(text) {
            document.getElementById('textInput').value = text;
            const result = expressionSystem.analyzeSentiment(text);
            console.log('Preset sentiment analysis:', result);
            
            setTimeout(() => {
                document.getElementById('textInput').value = '';
            }, 1000);
        }
        
        function startPerformanceMonitoring() {
            if (performanceInterval) clearInterval(performanceInterval);
            
            performanceInterval = setInterval(() => {
                const metrics = expressionSystem.getPerformanceMetrics();
                
                document.getElementById('fpsMetric').textContent = Math.round(metrics.fps);
                document.getElementById('emotionMetric').textContent = metrics.currentEmotion;
                document.getElementById('queueMetric').textContent = metrics.queueLength;
                document.getElementById('framesMetric').textContent = metrics.animationFrames;
                if (document.getElementById('qualityMetric')) {
                    document.getElementById('qualityMetric').textContent = metrics.quality;
                }
            }, 500);
        }

        function demoExpressions() {
            const emotions = ['happy', 'amazed', 'confused', 'determined', 'surprised', 'ecstatic', 'thinking', 'neutral'];
            let index = 0;
            
            const cycle = () => {
                expressionSystem.setExpression(emotions[index]);
                index = (index + 1) % emotions.length;
                
                setTimeout(cycle, 2500);
            };
            
            cycle();
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.altKey) {
                switch(e.key) {
                    case '1': setEmotion('neutral'); break;
                    case '2': setEmotion('happy'); break;
                    case '3': setEmotion('sad'); break;
                    case '4': setEmotion('surprised'); break;
                    case '5': setEmotion('thinking'); break;
                    case '6': setEmotion('speaking'); break;
                    case '7': setEmotion('confused'); break;
                    case '8': setEmotion('determined'); break;
                    case '9': setEmotion('concerned'); break;
                    case '0': setEmotion('amazed'); break;
                    case 'q': setEmotion('skeptical'); break;
                    case 'w': setEmotion('ecstatic'); break;
                }
            }
        });
    </script>
</body>
</html> 